<html><head><meta charset="utf-8"><title>Lista de Papers referenciados</title></head><body><h2>Título 1: Accumulation and Prioritization of Architectural Debt in Three Companies Migrating to Microservices</h2><h3>Autores: ['Saulo De Toledo', 'Antonio Martini', 'Phu Nguyen', 'Dag Sj{\\o}berg']</h3><h4>Ano: 2022</h4><p>Many companies migrate to microservices because they help deliver value to customers quickly and continuously. However, like any architectural style, microservices are prone to architectural technical debt (ATD), which can be costly if the debts are not timely identified, avoided, or removed. During the early stages of migration, microservice-specific ATDs (MS-ATDs) may accumulate. For example, practitioners may decide to continue using poorly defined APIs in microservices while attempting to maintain compatibility with old functionalities. The riskiest MS-ATDs must be prioritized. Nevertheless, there is limited research regarding the prioritization of MS-ATDs in companies migrating to microservices. This study aims to identify, during migration, which MS-ATDs occur, are the most severe, and are the most challenging to solve. In addition, we propose a way to prioritize these debts. We conducted a multiple exploratory case study of three large companies that were early in the migration process to microservices. We interviewed 47 practitioners with several roles to identify the debts in their contexts. We report the MS-ATDs detected during migration, the MS-ATDs that practitioners estimate to occur in the future, and the MS-ATDs that practitioners report as difficult to solve. We discuss the results in the context of the companies involved in this study. In addition, we used a risk assessment approach to propose a way for prioritizing MS-ATDs. Practitioners from other organizations and researchers may use this approach to provide rankings to help identify and prioritize which MS-ATDs should be avoided or solved in their contexts.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/9732968">link</a><br><h2>Título 3: Empirical evaluation of an architectural technical debt index in the context of the Apache and ONAP ecosystems</h2><h3>Autores: ['Roberto Verdecchia', 'Ivano Malavolta', 'Patricia Lago', 'Ipek Ozkaya']</h3><h4>Ano: 2022</h4><p>Background Architectural Technical Debt (ATD) in a software-intensive system denotes architectural design choices which, while being suitable or even optimal when adopted, lower the maintainability and evolvability of the system in the long term, hindering future development activities. Despite the growing research interest in ATD, how to gain an informative and encompassing viewpoint of the ATD present in a software-intensive system is still an open problem. Objective In this study, we evaluate ATDx, a data-driven approach providing an overview of the ATD present in a software-intensive system. The approach, based on the analysis of a software portfolio, calculates severity levels of architectural rule violations via a clustering algorithm, and aggregates results into different ATD dimensions. Method To evaluate ATDx, we implement an instance of the approach based on SonarQube, and run the analysis on the Apache and ONAP ecosystems. The analysis results are then shared with the portfolio contributors, who are invited to participate in an online survey designed to evaluate the representativeness and actionability of the approach. Results The survey results confirm the representativeness of the ATDx, in terms of both the ATDx analysis results and the used architectural technical debt dimensions. Results also showed the actionability of the approach, although to a lower extent when compared to the ATDx representativeness, with usage scenarios including refactoring, code review, communication, and ATD evolution analysis. Conclusions With ATDx, we strive for the establishment of a sound, comprehensive, and intuitive architectural view of the ATD identifiable via source code analysis. The collected results are promising, and display both the representativeness and actionability of the approach. As future work, we plan to consolidate the approach via further empirical experimentation, by considering other development contexts (e.g., proprietary portfolios and other source code analysis tools), and enhancing the ATDx report capabilities.</p><br><a href="https://peerj.com/articles/cs-833/">link</a><br><h2>Título 2: On the relation between architectural smells and source code changes</h2><h3>Autores: ['Darius Sas', 'Paris Avgeriou', 'Ilaria Pigazzini', 'Francesca Arcelli Fontana']</h3><h4>Ano: 2022</h4><p>Although architectural smells are one of the most studied type of architectural technical debt, their impact on maintenance effort has not been thoroughly investigated. Studying this impact would help to understand how much technical debt interest is being paid due to the existence of architecture smells and how this interest can be calculated. This work is a first attempt to address this issue by investigating the relation between architecture smells and source code changes. Specifically, we study whether the frequency and size of changes are correlated with the presence of a selected set of architectural smells. We detect architectural smells using the Arcan tool, which detects architectural smells by building a dependency graph of the system analyzed and then looking for the typical structures of the architectural smells. The findings, based on a case study of 31 open-source Java systems, show that 87% of the analyzed commits present more changes in artifacts with at least one smell, and the likelihood of changing increases with the number of smells. Moreover, there is also evidence to confirm that change frequency increases after the introduction of a smell and that the size of changes is also larger in smelly artifacts. These findings hold true especially in Medium–Large and Large artifacts.</p><br><a href="https://onlinelibrary.wiley.com/doi/full/10.1002/smr.2398">link</a><br><h2>Título 4: The influence of cognitive biases on architectural technical debt</h2><h3>Autores: ['Klara Borowa', 'Andrzej Zalewski', 'Szymon Kijas']</h3><h4>Ano: 2021</h4><p>Cognitive biases exert a significant influence on human thinking and decision-making. In order to identify how they influence the occurrence of architectural technical debt, a series of semi-structured interviews with software architects was performed. The results show which classes of architectural technical debt originate from cognitive biases, and reveal the antecedents of technical debt items (classes) through biases. This way, we analysed how and when cognitive biases lead to the creation of technical debt. We also identified a set of debiasing techniques that can be used in order to prevent the negative influence of cognitive biases. The observations of the role of organisational culture in the avoidance of inadvertent technical debt throw a new light on that issue.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/9426715">link</a><br><h2>Título 5: ATDx: A tool for providing a data-driven overview of architectural technical debt in software-intensive systems</h2><h3>Autores: ['Sebastian Ospina', 'Roberto Verdecchia', 'Ivano Malavolta', 'Patricia Lago']</h3><h4>Ano: 2021</h4><p>Architectural technical debt (ATD) in software-intensive systems is mostly invisible to software developers, can be widespread throughout entire code-bases, and its remediation cost is often steep. In
recent years, numerous approaches have been proposed to identify, keep track, and ultimately manage
ATD. The variety of approaches available opens a new problem, namely how to gain an encompassing
overview of the ATD identified in a software-intensive system. With this paper we make available the
ATDx tool, an implementation of ATDx written in Python, designed in a plug-in fashion. ATDx is an
approach designed to provide a data-driven, intuitive, and actionable overview of the ATD present in
a portfolio of software projects. ATDx is based on third-party source code analysis tools, architectural
issue severity calculation via clustering, and aggregation of measurements into different architectural
technical debt dimensions. The ATDx tool allows users to automatically run the ATDx analysis, generate reports containing the ATDx analysis results, and is integrated with GitHub. In addition to the tool,
we provide two already implemented plugins, allowing users to run the ATDx tool out-of-the-box.
GitHub repository: https://github.com/S2-group/ATDx
Video: https://youtu.be/ULT9fgxuB7E</p><br><a href="https://www.researchgate.net/profile/Roberto-Verdecchia/publication/353411185_ATDx_A_tool_for_Providing_a_Data-driven_Overview_of_Architectural_Technical_Debt_in_Software-intensive_Systems/links/60fac6130c2bfa282af72655/ATDx-A-tool-for-Providing-a-Data-driven-Overview-of-Architectural-Technical-Debt-in-Software-intensive-Systems.pdf">link</a><br><h2>Título 6: Systematically reviewing the layered architectural pattern principles and their use to reconstruct software architectures</h2><h3>Autores: ['Alvine Belle', 'Ghizlane Boussaidi', 'Timothy Lethbridge', 'Segla Kpodjedo', 'Hafedh Mili', 'Andres Paz']</h3><h4>Ano: 2021</h4><p>Architectural reconstruction is a reverse engineering activity aiming at recovering the missing decisions on a system. It can help identify the components, within a legacy software application, according to the application's architectural pattern. It is useful to identify architectural technical debt. We are interested in identifying layers within a layered application since the layered pattern is one of the most used patterns to structure large systems. Earlier component reconstruction work focusing on that pattern relied on generic component identification criteria, such as cohesion and coupling. Recent work has identified architectural-pattern specific criteria to identify components within that pattern. However, the architectural-pattern specific criteria that the layered pattern embodies are loosely defined. In this paper, we present a first systematic literature review (SLR) of the literature aiming at inventorying such criteria for layers within legacy applications and grouping them under four principles that embody the fundamental design principles under-lying the architectural pattern. We identify six such criteria in the form of design rules. We also perform a second systematic literature review to synthesize the literature on software architecture reconstruction in the light of these criteria. We report those principles, the rules they encompass, their representation, and their usage in software architecture reconstruction.</p><br><a href="https://arxiv.org/abs/2112.01644">link</a><br><h2>Título 7: Identifying architectural technical debt, principal, and interest in microservices: A multiple-case study</h2><h3>Autores: ['Saulo Toledo', 'Antonio Martini', 'Dag Sj{\\o}berg']</h3><h4>Ano: 2021</h4><p>Background:
Using a microservices architecture is a popular strategy for software organizations to deliver value to their customers fast and continuously. However, scientific knowledge on how to manage architectural debt in microservices is scarce.
Objectives:
In the context of microservices applications, this paper aims to identify architectural technical debts (ATDs), their costs, and their most common solutions.
Method:
We conducted an exploratory multiple case study by conducting 25 interviews with practitioners working with microservices in seven large companies.
Results:
We found 16 ATD issues, their negative impact (interest), and common solutions to repay each debt together with the related costs (principal). Two examples of critical ATD issues found were the use of shared databases that, if not properly planned, leads to potential breaks on services every time the database schema changes and bad API designs, which leads to coupling among teams. We identified ATDs occurring in different domains and stages of development and created a map of the relationships among those debts.
Conclusion:
The findings may guide organizations in developing microservices systems that better manage and avoid architectural debts.</p><br><a href="https://www.sciencedirect.com/science/article/pii/S0164121221000650">link</a><br><h2>Título 8: The perception of Architectural Smells in industrial practice</h2><h3>Autores: ['Darius Sas', 'Ilaria Pigazzini', 'Paris Avgeriou', 'Francesca Fontana']</h3><h4>Ano: 2021</h4><p>Architectural technical debt (TD) is the most significant type of TD in industrial practice. Our goals in this study were to better understand the phenomenon of architectural smells, help practitioners better manage them, and offer relevant support to researchers</p><br><a href="https://ieeexplore.ieee.org/abstract/document/9509940">link</a><br><h2>Título 9: Reducing Incidents in Microservices by Repaying Architectural Technical Debt</h2><h3>Autores: ['Saulo Toledo', 'Antonio Martini', 'Dag Sjoberg', 'Agata Przybyszewska', 'Johannes Frandsen']</h3><h4>Ano: 2021</h4><p>Architectural technical debt (ATD) may create a substantial extra effort in software development, which is called interest. There is little evidence about whether repaying ATD in microservices reduces such interest. Objectives: We wanted to conduct a first study on investigating the effect of removing ATD on the occurrence of incidents in a microservices architecture. Method: We conducted a quantitative and qualitative case study of a project with approximately 1000 microservices in a large, international financing services company. We measured and compared the number of software incidents of different categories before and after repaying ATD. Results: The total number of incidents was reduced by 84\%, and the numbers of critical- and high-priority incidents were both reduced by approximately 90\% after the architectural refactoring. The number of incidents in the architecture with the ATD was mainly constant over time, but we observed a slight increase of low priority incidents related to inaccessibility and the environment in the architecture without the ATD. Conclusion: This study shows evidence that refactoring ATDs, such as lack of communication standards, poor management of dead-letter queues, and the use of inadequate technologies in microservices, reduces the number of critical- and high-priority incidents and, thus, part of its interest, although some low priority incidents may increase.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/9582573">link</a><br><h2>Título 10: Uma ferramenta de visualiza{\c{c}}{\~a}o de software para avalia{\c{c}}{\~a}o de uso de API no contexto de ecossistemas de software</h2><h3>Autores: ['Rodrigo Avancini']</h3><h4>Ano: 2021</h4><p>Software Ecosystem (SECO) is a consolidated research area of Software Engineering,
emerging as a paradigm for understanding the dynamics and relationships among
software systems that collaborate with each other to achieve their goals. Understanding a software ecosystem and how its elements interact is essential for the evolution
of the systems involved, especially for those that provide functions and services for
other systems, such as APIs. Since an API is being used by other applications, future
changes need to be made in a systematic and appropriate manner, considering its
ecosystem. However, there is still a great demand to develop effective ways to evaluate API usage in the context of SECO. Thus, in this work, Ecolyzer was developed, a
software visualization tool that aims to support the analysis and evaluation of the use
of an API, through an interactive visualization and metrics that consider its ecosystem. To show the feasibility and implementability of the proposed solution, a proof
of concept (PoC) was first conducted using an open-source API written in the Lua
programming language. Then, an evaluation was made of the use of an open-source
API written in Java, widely used by other applications. The results obtained with
Ecolyzer were satisfactory and show that the tool is useful and promising, providing
important insights to assist in strategic planning for the evolution of APIs, taking into
account their ecosystems</p><br><a href="http://200.144.93.16/bitstream/handle/11600/61800/RodrigoAvancini_DissertacaoMestrado_UNIFESP.pdf?sequence=1&isAllowed=y">link</a><br><h2>Título 11: Building and evaluating a theory of architectural technical debt in software-intensive systems</h2><h3>Autores: ['Roberto Verdecchia', 'Philippe Kruchten', 'Patricia Lago', 'Ivano Malavolta']</h3><h4>Ano: 2021</h4><p>Architectural technical debt in software-intensive systems is a metaphor used to describe the “big” design decisions (e.g., choices regarding structure, frameworks, technologies, languages, etc.) that, while being suitable or even optimal when made, significantly hinder progress in the future. While other types of debt, such as code-level technical debt, can be readily detected by static analyzers, and often be refactored with minimal or only incremental efforts, architectural debt is hard to be identified, of wide-ranging remediation cost, daunting, and often avoided. In this study, we aim at developing a better understanding of how software development organizations conceptualize architectural debt, and how they deal with it. In order to do so, in this investigation we apply a mixed empirical method, constituted by a grounded theory study followed by focus groups. With the grounded theory method we construct a theory on architectural technical debt by eliciting qualitative data from software architects and senior technical staff from a wide range of heterogeneous software development organizations. We applied the focus group method to evaluate the emerging theory and refine it according to the new data collected. The result of the study, i.e., a theory emerging from the gathered data, constitutes an encompassing conceptual model of architectural technical debt, identifying and relating concepts such as its symptoms, causes, consequences, management strategies, and communication problems. From the conducted focus groups, we assessed that the theory adheres to the four evaluation criteria of classic grounded theory, i.e., the theory fits its underlying data, is able to work, has relevance, and is modifiable as new data appears. By grounding the findings in empirical evidence, the theory provides researchers and practitioners with novel knowledge on the crucial factors of architectural technical debt experienced in industrial contexts.</p><br><a href="https://www.sciencedirect.com/science/article/pii/S0164121221000224">link</a><br><h2>Título 12: Detecting the Locations and Predicting the Costs of Compound Architectural Debts</h2><h3>Autores: ['Lu Xiao', 'Yuanfang Cai', 'Rick Kazman', 'Ran Mo', 'Qiong Feng']</h3><h4>Ano: 2021</h4><p>Architectural Technical Debt (ATD) refers to sub-optimal architectural design in a software system that incurs high maintenance interest over time. Previous research revealed that ATD has significant negative impact on daily development. This paper contributes an approach to enable an architect to precisely locate ATDs, as well as capture the trajectory of maintenance cost on each debt, based on which, predict the cost of the debt in a future release. The ATDs are expressed in four typical patterns, which entail the core of each debt. Furthermore, we aggregate compound ATDs to capture the complicated relationship among multiple ATD instances, which should be examined together for effective refactoring solutions. We evaluate our approach on 18 real-world projects. We identified ATDs that persistently incur significant (up to 95% of) maintenance costs in most projects. The maintenance costs on the majority of debts fit into a linear regression model---indicating stable interest rate. In five projects, 12.1% to 27.6% of debts fit into an exponential model, indicating increasing interest rate, which deserve higher priority from architects. The regression models can accurately predict the costs of the majority of (82% to 100%) debts in the next release of a system. By aggregating related ATDs, architects can focus on a small number of cost-effective compound debts, which contain a relatively small number of source files, but account for a large portion of maintenance costs in their projects. With these capabilities, our approach can help architects make informed decisions regarding whether, where, and how to refactor for eliminating ATDs in their systems.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/9508122">link</a><br><h2>Título 17: Architectural technical debt: A grounded theory</h2><h3>Autores: ['Roberto Verdecchia', 'Philippe Kruchten', 'Patricia Lago']</h3><h4>Ano: 2020</h4><p>Architectural technical debt in a software-intensive system is driven by design decisions about its structure, frameworks, technologies, languages, etc. Unlike code-level technical debt, which can be readily detected by static analysers, and can often be refactored with minimal efforts, architectural debt is hard to detect, and its remediation is wide-ranging, daunting, and often avoided. The objective of this study is to develop a better understanding of how software development organisations conceptualize their architectural debt, and how they deal with it, if at all. We used a grounded theory method, eliciting qualitative data from software architects and senior technical staff from a wide range of software development organizations. The result of the study, i.e., the theory emerging from the collected data, constitutes an encompassing conceptual theory of architectural debt, identifying and relating concepts such as symptoms, causes, consequences, and management strategies. By grounding the findings in empirical data, the theory provides researchers and practitioners with evidence of which crucial factors of architectural technical debt are experienced in industrial contexts.</p><br><a href="https://link.springer.com/chapter/10.1007/978-3-030-58923-3_14">link</a><br><h2>Título 20: ATDx: Building an Architectural Technical Debt Index.</h2><h3>Autores: ['Roberto Verdecchia', 'Patricia Lago', 'Ivano Malavolta', 'Ipek Ozkaya']</h3><h4>Ano: 2020</h4><p>Architectural technical debt (ATD) in software-intensive systems refers to the architecture design decisions which work as expedient in the short term, but later negatively impact system evolvability and maintainability. Over the years numerous approaches have been proposed to detect particular types of ATD at a refined level of granularity via source code analysis. Nevertheless, how to gain an encompassing overview of the ATD present in a software-intensive system is still an open question. In this study, we present a multi-step approach designed to build an ATD index (ATDx), which provides insights into a set of ATD dimensions building upon existing architectural rules by leveraging statistical analysis. The ATDx approach can be adopted by researchers and practitioners alike in order to gain a better understanding of the nature of the ATD present in software-intensive systems, and provides a systematic framework to implement concrete instances of ATDx according to specific project and organizational needs</p><br><a href="https://www.scitepress.org/Papers/2020/95778/95778.pdf">link</a><br><h2>Título 19: Software archinaut: a tool to understand architecture, identify technical debt hotspots and manage evolution</h2><h3>Autores: ['Humberto Cervantes', 'Rick Kazman']</h3><h4>Ano: 2020</h4><p>In this paper we present Software Archinaut-a tool used to help identify technical debt hotspots in an architecture, and manage the evolution of the architecture once these hotspots are discovered. Archinaut is a platform that integrates analyses from different tools. It supports three main usage scenarios: 1) understanding the architecture, 2) identifying technical debt hotspots, and 3) monitoring and controlling the evolution of the architecture. We illustrate these scenarios by using Apache Kafka as an example.</p><br><a href="https://dl.acm.org/doi/abs/10.1145/3387906.3388633">link</a><br><h2>Título 18: Identification of co-change patterns in software evolution</h2><h3>Autores: ['Anushree Agrawal', 'RK Singh']</h3><h4>Ano: 2020</h4><p>Tracking the after-effect of changes is very difficult due to complex and huge structure of software applications now days. Researchers have found that revision history is very useful in deriving dependencies in software applications. However it is difficult to choose the right history length that is useful for dependency identification. Also all the new and old commits do not have the same potential in identifying dependencies. In this paper, we propose the use of change history for measuring the co-change probability in software applications by varying the weightage of change commits. Academicians and researchers may find this approach useful for studying the effect of revision age on cochange prediction results.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/9197979">link</a><br><h2>Título 14: A semiautomatic approach to identify architectural technical debt from heterogeneous artifacts</h2><h3>Autores: ["Boris P{\\'e}rez"]</h3><h4>Ano: 2020</h4><p>Architectural Technical Debt (ATD) is a metaphor used to describe decisions taken by software architects to accomplish short-term goals but possibly negatively affecting the long-term health of the system. However, ATD doesn’t receive enough attention for the architect teams because it is hard to identify, to measure, to prioritize, and its value is related to long-term maintenance and evolution of a system. In this research, we propose a model-driven approach that focuses on building a binary classification model for ATD identification based on the information gathered from artifacts produced during architecture design. This model will allow software architects to support the managing of conscious and unconscious ATD in their software projects. This proposal focuses on TD at the architecture-level only without considering source code. The effectiveness of this proposal will be evaluated using case studies and expert interviews.</p><br><a href="https://link.springer.com/chapter/10.1007/978-3-030-59155-7_1">link</a><br><h2>Título 16: An empirical investigation on the relationship between design and architecture smells</h2><h3>Autores: ['Tushar Sharma', 'Paramvir Singh', 'Diomidis Spinellis']</h3><h4>Ano: 2020</h4><p>Context:
Architecture of a software system represents the key design decisions and therefore its quality plays an important role to keep the software maintainable. Code smells are indicators of quality issues in a software system and are classified based on their granularity, scope, and impact. Despite a plethora of existing work on smells, a detailed exploration of architecture smells, their characteristics, and their relationships with smells in other granularities is missing.
Objective:
The paper aims to study architecture smells characteristics, investigate correlation, collocation, and causation relationships between architecture and design smells.
Method:
We implement smell detection support for seven architecture smells. We mine 3 073 open-source repositories containing more than 118 million lines of C# code and empirically investigate the relationships between seven architecture and 19 design smells.
Results:
We find that smell density does not depend on repository size. Cumulatively, architecture smells are highly correlated with design smells. Our collocation analysis finds that the majority of design and architecture smell pairs do not exhibit collocation. Finally, our causality analysis reveals that design smells cause architecture smells.</p><br><a href="https://link.springer.com/article/10.1007/s10664-020-09847-2">link</a><br><h2>Título 15: Improving agility by managing shared libraries in microservices</h2><h3>Autores: ['Saulo Toledo', 'Antonio Martini', 'Dag Sj{\\o}berg']</h3><h4>Ano: 2020</h4><p>Using microservices is a way of supporting an agile architecture. However, if the microservices development is not properly managed, the teams’ development velocity may be affected, reducing agility and increasing architectural technical debt. This paper investigates how to manage the use of shared libraries in microservices to improve agility during development. We interviewed practitioners from four large international companies involved in microservices projects to identify problems when using shared libraries. Our results show that the participating companies had issues with shared libraries as follows: coupling among teams, delays on fixes due to overhead on libraries development teams, and need to maintain many versions of the libraries. Our results highlight that the use of shared libraries may hinder agility on microservices. Thus, their use should be restricted to situations where shared libraries cannot be replaced by a microservice and the costs of replicating the code on each service is very high.</p><br><a href="https://link.springer.com/chapter/10.1007/978-3-030-58858-8_20">link</a><br><h2>Título 13: Technical debt aware estimations in software engineering: a systematic mapping study</h2><h3>Autores: ['Pawe{\\l} Klimczyk', 'Lech Madeyski']</h3><h4>Ano: 2020</h4><p>Context: The Technical Debt metaphor has grown in popularity. More software is being created and has to be maintained. Agile methodologies, in particular Scrum, are widely used by development teams around the world. Estimation is an often practised step in sprint planning. The subject matter of this paper is the impact technical debt has on estimations. Objective: The goal of this research is to identify estimation problems and their solutions due to previously introduced technical debt in software projects. Method: The Systematic mapping study (SMS) method was applied in the research. Papers were selected from the popular digital databases (IEEE, ACM, Scopus, etc.) using defined search criteria. Afterwards, a snowballing procedure was performed and the final publication set was filtered using inclusion/exclusion criteria. Results: 42 studies were selected and evaluated. Five categories of problems and seven proposed solutions to the problems have been extracted from the papers. Problems include items related to business perspective (delivery pressure or lack of technical debt understanding by business decision-makers) and technical perspective (difficulties in forecasting architectural technical debt impact or limits of source code analysis). Solutions were categorized in: more sophisticated decision-making tools for business managers, better tools for estimation support and technical debt management tools on an architectural-level, portfolio approach to technical debt, code audit and technical debt reduction routine conducted every sprint. Conclusion: The results of this mapping study can help taking the appropriate approach in technical debt mitigation in organizations. However, the outcome of the conducted research shows that the problem of measuring technical debt impact on estimations has not yet been solved. We propose several directions for further investigation. In particular, we would focus on more sophisticated decision-making tools.</p><br><a href="https://yadda.icm.edu.pl/baztech/element/bwmeta1.element.baztech-bed61889-8adb-4503-943d-dec871dbe4ac">link</a><br><h2>Título 29: Architectural smells detected by tools: a catalogue proposal</h2><h3>Autores: ['Umberto Azadi', 'Francesca Fontana', 'Davide Taibi']</h3><h4>Ano: 2019</h4><p>Architectural smells can negatively impact on different software qualities and can represent a relevant source of architectural debt. Several architectural smells have been defined by different researchers. Moreover, both academia and industry proposed several tools for software quality analysis, but it is not always clear to understand which tools provide also support for architectural smells detection and if the tools developed for this specific purpose are effectively available or not. In this paper we propose a catalogue of architectural smells for which, at least one tool able to detect the smell exists. We outline the main differences in the detection techniques exploited by the tools and we propose a classification of these architectural smells according to the violation of three design principles.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/8785058">link</a><br><h2>Título 35: Technical debt triage in backlog management</h2><h3>Autores: ['Terese Besker', 'Antonio Martini', 'Jan Bosch']</h3><h4>Ano: 2019</h4><p>Remediation of technical debt through regular refactoring initiatives is considered vital for the software system's long and healthy life. However, since today's software companies face increasing pressure to deliver customer value continuously, the balance between spending developer time, effort, and resources on implementing new features or spending it on refactoring of technical debt becomes vital. The goal of this study is to explore how the prioritization of technical debt is carried out by practitioners within today's software industry. This study also investigates what factors influence the prioritization process and its related challenges. This paper reports the results of surveying 17 software practitioners, together with follow-up interviews with them. Our results show that there is no uniform way of prioritizing technical debt and that it is commonly done reactively without applying any explicit strategies. Often, technical debt issues are managed and prioritized in a shadow backlog, separate from the official sprint backlog. This study was also able to identify several different challenges related to prioritizing technical debt, such as the lack of quantitative information about the technical debt items and that the refactoring of technical debt issues competes with the implementation of customer requirements.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/8786030">link</a><br><h2>Título 34: VisminerTD: a tool for automatic identification and interactive monitoring of the evolution of technical debt items</h2><h3>Autores: ['Thiago Mendes', 'Felipe Gomes', 'David Gon{\\c{c}}alves', 'Manoel Mendon{\\c{c}}a', 'Renato Novais', "Rodrigo Sp{\\'\\i}nola"]</h3><h4>Ano: 2019</h4><p>Technical debt (TD) contextualizes problems faced during software evolution considering the tasks that are not carried out adequately during software development. Software TD is a type of debt that brings a short-term benefit, but which may have to be paid with interest later on in the software development life cycle. Its presence brings risks to the project and can reduce its quality. It is worthwhile to have automatic mechanisms to monitor it, as TD monitoring requires the analysis of large amounts of complex data. Therefore, the combination of software metrics and code comment analysis, in the identification, and information visualization techniques, in monitoring, present themselves as a promising strategy to manage TD. This work presents VisminerTD, a tool that allows the automatic identification and interactive monitoring of the evolution of TD items by combining software metrics, code comment analysis, and information visualization. To evaluate its applicability, a feasibility study was carried out considering JUnit 4 and Apache Ant software projects. The results indicated that VisminerTD can support software development teams in monitoring TD items. In addition, a second case study was performed to assess the feasibility of the proposed tool regarding its usefulness, ease of use, and self-predicted future use. The results provided positive evidence on the use of the proposed tool, indicating (i) that it can be useful in supporting TD Identification and TD monitoring activities and (ii) that it can bring gains in terms of comprehensiveness and efficacy when evaluating the desirable time to identify and monitor different types of debt. Given the current scenario characterized by limited options of tools that combine different information to support automatic identification and monitoring of the evolution of TD items in software projects, VisminerTD can approximate the state-of-the-art and the state-of-the-practice in the TD area, contributing to a wider dissemination of the concept.</p><br><a href="https://link.springer.com/article/10.1186/s13173-018-0083-1">link</a><br><h2>Título 33: Your code as a crime scene</h2><h3>Autores: ['Adam Tornhill']</h3><h4>Ano: 2019</h4><p>Inspired by forensic psychology methods, this book teaches strategies to predict the future of your codebase, assess refactoring direction, and understand how your team influences the design. With its unique blend of forensic psychology and code analysis, it arms you with the strategies you need, no matter what programming language you use.</p><br><a href="https://www.torrossa.com/en/resources/an/5241725">link</a><br><h2>Título 32: Active hotspot: An issue-oriented model to monitor software evolution and degradation</h2><h3>Autores: ['Qiong Feng', 'Yuanfang Cai', 'Rick Kazman', 'Di Cui', 'Ting Liu', 'Hongzhou Fang']</h3><h4>Ano: 2019</h4><p>Architecture degradation has a strong negative impact on software quality and can result in significant losses. Severe software degradation does not happen overnight. Software evolves continuously, through numerous issues, fixing bugs and adding new features, and architecture flaws emerge quietly and largely unnoticed until they grow in scope and significance when the system becomes difficult to maintain. Developers are largely unaware of these flaws or the accumulating debt as they are focused on their immediate tasks of address individual issues. As a consequence, the cumulative impacts of their activities, as they affect the architecture, go unnoticed. To detect these problems early and prevent them from accumulating into severe ones we propose to monitor software evolution by tracking the interactions among files revised to address issues. In particular, we propose and show how we can automatically detect active hotspots, to reveal architecture problems. We have studied hundreds of hotspots along the evolution timelines of 21 open source projects and showed that there exist just a few dominating active hotspots per project at any given time. Moreover, these dominating active hotspots persist over long time periods, and thus deserve special attention. Compared with state-of-the-art design and code smell detection tools we report that, using active hotspots, it is possible to detect signs of software degradation both earlier and more precisely.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/8952512">link</a><br><h2>Título 31: Investigating instability architectural smells evolution: an exploratory case study</h2><h3>Autores: ['Darius Sas', 'Paris Avgeriou', 'Francesca Fontana']</h3><h4>Ano: 2019</h4><p>Architectural smells may substantially increase maintenance effort and thus require extra attention for potential refactoring. While we currently understand this concept and have identified different types of such smells, we have not yet studied their evolution in depth. This is necessary to inform their prioritisation and refactoring. This study analyses the evolution of individual architectural smell instances over time, and the characteristics that define these instances. Three different types of architectural smells are taken into consideration and mined from a total of 524 versions across 14 different projects. The results show how different smell types differ in multiple aspects, such as their growth rate, the importance of the affected elements over time in the dependency network of the system, and the time each instance affects the system. They also cast valuable insights on what aspects are the most important to consider during prioritisation and refactoring activities.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/8919109">link</a><br><h2>Título 30: Mitigating Technical and Architectural Debt with Sonargraph</h2><h3>Autores: ['Alexander Zitzewitz']</h3><h4>Ano: 2019</h4><p>Sonargraph is a static analyzer with a focus on software architecture and metrics. The motivation to create Sonargraph came from the assumption that architectural debt (aka structural debt) is the most toxic form of technical debt. Repairing a broken architecture requires global and high-risk changes, while fixing other forms of technical debt mostly involves low-risk local changes. Therefore, the tool enables architects and developers to formally describe their architectural blueprint using a custom DSL (domain specific language). Once defined architectural rules can be checked and enforced in an automated way in all stages of the development process. This guarantees that a software system will never end up as the notorious "big ball of mud". Sonargraph currently supports Java, C#, C/C++ and Python and is used by hundreds of organizations worldwide.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/8786002">link</a><br><h2>Título 22: Evolution of the Unix system architecture: an exploratory case study</h2><h3>Autores: ['Diomidis Spinellis', 'Paris Avgeriou']</h3><h4>Ano: 2019</h4><p>Unix has evolved for almost five decades, shaping modern operating systems, key software technologies, and development practices. Studying the evolution of this remarkable system from an architectural perspective can provide insights on how to manage the growth of large, complex, and long-lived software systems. Along main Unix releases leading to the FreeBSD lineage we examine core architectural design decisions, the number of features, and code complexity, based on the analysis of source code, reference documentation, and related publications. We report that the growth in size has been uniform, with some notable outliers, while cyclomatic complexity has been religiously safeguarded. A large number of Unix-defining design decisions were implemented right from the very early beginning, with most of them still playing a major role. Unix continues to evolve from an architectural perspective, but the rate of architectural innovation has slowed down over the system's lifetime. Architectural technical debt has accrued in the forms of functionality duplication and unused facilities, but in terms of cyclomatic complexity it is systematically being paid back through what appears to be a self-correcting process. Some unsung architectural forces that shaped Unix are the emphasis on conventions over rigid enforcement, the drive for portability, a sophisticated ecosystem of other operating systems and development organizations, and the emergence of a federated architecture, often through the adoption of third-party subsystems. These findings have led us to form an initial theory on the architecture evolution of large, complex operating system software.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/8704965">link</a><br><h2>Título 28: Managing Technical Debt: Reducing Friction in Software Development</h2><h3>Autores: ['Philippe Kruchten', 'Robert Nord', 'Ipek Ozkaya']</h3><h4>Ano: 2019</h4><p>?</p><br><a href="https://books.google.com.br/books?hl=en&lr=&id=R3qSDwAAQBAJ&oi=fnd&pg=PT15&dq=Managing+Technical+Debt:+Reducing+Friction+in+Software+Development&ots=fplJY-lUlS&sig=0mCG9EfAXGT3XiZAfDzA4Vq094E&redir_esc=y#v=onepage&q=Managing%20Technical%20Debt%3A%20Reducing%20Friction%20in%20Software%20Development&f=false">link</a><br><h2>Título 27: A proposed model-driven approach to manage architectural technical debt life cycle</h2><h3>Autores: ["Boris P{\\'e}rez", "Dar{\\'\\i}o Correal", "Hern{\\'a}n Astudillo"]</h3><h4>Ano: 2019</h4><p>Architectural Technical Debt (ATD) is a metaphor used to describe consciously decisions taken by software architects to accomplish short-term goals but possibly negatively affecting the long-term health of the system. However, difficulties arise when repayment strategies are defined because software architects need to be aware of the consequences of these strategies over others decisions in the software architecture. This article proposes REBEL, a semi-automated model-driven approach that exploits natural language processing, machine learning and model checking techniques on heterogeneous project artifacts to build a model that allows to locate and visualize the impact produced by the consciously injected ATD and its repayment strategy on the other architectural decisions. The technique is illustrated with a data analytics project in Colombia where software architects are unaware of the consequences of the repayment strategies. This proposal seeks to support teams of architects to make explicit the current and future impact of the ATD injected as a result of decisions taken, focusing on the architectural level rather than code level.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/8786037">link</a><br><h2>Título 26: Assuring the evolvability of microservices: insights into industry practices and challenges</h2><h3>Autores: ['Justus Bogner', 'Jonas Fritzsch', 'Stefan Wagner', 'Alfred Zimmermann']</h3><h4>Ano: 2019</h4><p>While Microservices promise several beneficial characteristics for sustainable long-term software evolution, little empirical research covers what concrete activities industry applies for the evolvability assurance of Microservices and how technical debt is handled in such systems. Since insights into the current state of practice are very important for researchers, we performed a qualitative interview study to explore applied evolvability assurance processes, the usage of tools, metrics, and patterns, as well as participants' reflections on the topic. In 17 semi-structured interviews, we discussed 14 different Microservice-based systems with software professionals from 10 companies and how the sustainable evolution of these systems was ensured. Interview transcripts were analyzed with a detailed coding system and the constant comparison method. We found that especially systems for external customers relied on central governance for the assurance. Participants saw guidelines like architectural principles as important to ensure a base consistency for evolvability. Interviewees also valued manual activities like code review, even though automation and tool support was described as very important. Source code quality was the primary target for the usage of tools and metrics. Despite most reported issues being related to Architectural Technical Debt (ATD), our participants did not apply any architectural or service-oriented tools and metrics. While participants generally saw their Microservices as evolvable, service cutting and finding an appropriate service granularity with low coupling and high cohesion were reported as challenging. Future Microservices research in the areas of evolution and technical debt should take these findings and industry sentiments into account.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/8919247">link</a><br><h2>Título 25: Architectural technical debt in embedded systems</h2><h3>Autores: ['Antonio Martini', 'Jan Bosch']</h3><h4>Ano: 2019</h4><p>Agile software development (ASD) has been employed effectively in the development of embedded systems, contributing to speeding up the delivery of value to the customers. However, some obstacles have been found, limiting the application of ASD to such a domain. This chapter focuses on one such challenges, the degradation of the system architecture over time, which is called, in literature, Architectural Technical Debt (ATD). Software engineering is an individual activity and the causes for ATD accumulation can be related to suboptimal decision taken by individual employees. New employees as well are more subjected to accumulating ATD due to the natural noncomplete understanding of the architecture and patterns. The chapter summarizes the causes, trends, consequences, and possible solutions related to the management of ATD. The results are all based on a strong collaboration with several software-intensive systems industries located in northern Europe and, consequently, relevant to all Industry 4.0 companies.</p><br><a href="https://onlinelibrary.wiley.com/doi/abs/10.1002/9781119513957.ch4">link</a><br><h2>Título 24: Software architecture social debt: Managing the incommunicability factor</h2><h3>Autores: ['Damian Tamburri']</h3><h4>Ano: 2019</h4><p>Architectural technical debt is the additional project cost connected to technical issues nested in software architectures. Similarly, many practitioners have already experienced that there exists within software architectures a form of social debt, that is, the additional project cost connected to sociotechnical and organizational issues evident in or related to software architectures. This paper illustrates four recurrent antipatterns or community smells connected to such architectural social debt and outlines a means to measure the additional project cost connected to their underlying cause: decision incommunicability. Evaluating the results in multiple focus groups, this paper concludes that studying social debt and community smells at the architecture level may prove vital to rid software development communities of critical organizational flaws incurring considerable additional cost.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/8613009">link</a><br><h2>Título 23: Measuring affective states from architectural technical debt</h2><h3>Autores: ['JESPER OLSSON', 'ERIK RISFELT']</h3><h4>Ano: 2019</h4><p>Context: While the technological and financial aspects of technical debt have been extensively researched, the consequences on human aspects remain mostly uncharted. At the same time, recent psychoempirical software engineering research links the affects of software practitioners to organisational performance. Objective: To empirically investigate the causal relationship between architectural technical debt and the affects of software practitioners. Method: A mixed-methods approach with 40 software practitioners from 12 companies was used, combining repeated measurements laboratory experiments and semi-structured interviews. Result: Based on a set of 200 data points, the existence of tiny tangles negatively impacts the valence of software practitioners with more than 99 % certainty. No links were found between professional background and variations in affective state. Moreover, software practitioners receive positive affects from challenging software engineering tasks and negative affects from architectural technical debt and deadlines. Limitation: The subjects were industry professionals obtained through convenience sampling. Additionally, the treatments, albeit similar to industry code, were small and isolated examples that lacked the full spread and severity of technical debt encountered in practice. Conclusion: By combining our results with the existing literature on psychoempirical software engineering, strong arguments can be made in favour of the hypothesis that the effects of technical debt on industry professionals carry high technological and financial risks.</p><br><a href="https://odr.chalmers.se/handle/20.500.12380/300046">link</a><br><h2>Título 21: Identifying scalability debt in open systems</h2><h3>Autores: ['Geir Hanssen', 'Gunnar Brataas', 'Antonio Martini']</h3><h4>Ano: 2019</h4><p>Architectural technical debt can be generated by changes in the business and the environment of an organization. In this paper, we emphasize the change in scalability requirements due to new regulations. Scalability is the ability of a system to handle an increased workload. For complex systems that are abruptly exposed via open interfaces and hence a greater workload, the scalability requirements may quickly increase, leading to technical debt. We term this scalability debt. This paper describes scalability triage, a light-weight, novel technique for identifying scalability threats as a form of technical debt. We illustrate this technique with an open banking case from a large software organization. Open banking is partly caused by the new European PSD2 regulative that enforce banks to open interfaces to unknown third-party actors. Banking systems are well-established, mature systems. However, with the advent of open banking and PSD2, the workload may quickly rocket. This leads to tougher scalability requirements and accumulated architectural debt, despite previously sound architectural decisions. Using scalability triage, such risks may be identified fast. It will then be possible to prevent this form of technical debt with timely reengineering.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/8785983">link</a><br><h2>Título 44: Ruffle: Extracting co-change information from software project repositories</h2><h3>Autores: ['Anushree Agrawal', 'RK Singh']</h3><h4>Ano: 2018</h4><p>Software maintenance is complex and exhaustive phase of SDLC. Incorporating new changes becomes very complicated due to several dependent entities in software applications. Therefore, tools and techniques that can identify dependencies among classes are extremely desirable in order to efficiently manage these changes. In this paper, we present Ruffle, a tool developed using java and python to generate change recommendations in software applications based upon the software revision history. These change recommendations can guide the developers and testers to identify dependencies in software applications and can be very beneficial in the maintenance phase. We have used five open source software applications to evaluate the performance of the proposed tool. The obtained results are promising and able to identify most of the dependent classes in the studied software applications.
</p><br><a href="https://ieeexplore.ieee.org/abstract/document/8748406">link</a><br><h2>Título 51: Architectural technical debt identification: The research landscape</h2><h3>Autores: ['Roberto Verdecchia', 'Ivano Malavolta', 'Patricia Lago']</h3><h4>Ano: 2018</h4><p>Architectural Technical Debt (ATD) regards sub-optimal design decisions that bring short-term benefits to the cost of long-term gradual deterioration of the quality of the architecture of a software system. The identification of ATD strongly in uences the technical and economic sustainability of software systems and is attracting growing interest in the scientific community. During the years several approaches for ATD identification have been conceived, each of them addressing ATD from diferent perspectives and with heterogeneous characteristics. In this paper we apply the systematic mapping study methodology for identifying, classifying, and evaluating the state of the art on ATD identification from the following three perspectives: publication trends, characteristics, and potential for industrial adoption. Specically, starting from a set of 509 potentially relevant studies, we systematically selected 47 primary studies and analyzed them according to a rigorously-de ned classification framework. The analysis of the obtained results supports both researchers and practitioners by providing (i) an assessment of current research trends and gaps in ATD identification, (ii) a solid foundation for understanding existing (and future) research on ATD identification, and (iii) a rigorous evaluation of its potential for industrial adoption.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/8595095">link</a><br><h2>Título 50: PyDriller: Python framework for mining software repositories</h2><h3>Autores: ['Davide Spadini', 'Mauricio Aniche', 'Alberto Bacchelli']</h3><h4>Ano: 2018</h4><p>Software repositories contain historical and valuable information about the overall development of software systems. Mining software repositories (MSR) is nowadays considered one of the most interesting growing fields within software engineering. MSR focuses on extracting and analyzing data available in software repositories to uncover interesting, useful, and actionable information about the system. Even though MSR plays an important role in software engineering research, few tools have been created and made public to support developers in extracting information from Git repository. In this paper, we present PyDriller, a Python Framework that eases the process of mining Git. We compare our tool against the state-of-the-art Python Framework GitPython, demonstrating that PyDriller can achieve the same results with, on average, 50% less LOC and significantly lower complexity.
URL: https://github.com/ishepard/pydriller
Materials: https://doi.org/10.5281/zenodo.1327363
Pre-print: https://doi.org/10.5281/zenodo.1327411</p><br><a href="https://dl.acm.org/doi/abs/10.1145/3236024.3264598">link</a><br><h2>Título 49: An architectural smells detection tool for c and c++ projects</h2><h3>Autores: ['Andrea Biaggi', 'Francesca Fontana', 'Riccardo Roveda']</h3><h4>Ano: 2018</h4><p>Architectural smells gained great attention in the past few years since they directly affect software quality and increase architectural technical debt. However, while it is straightforward to understand why they are important, it is more difficult to find techniques and tools to detect and remove architectural smells. The purpose of this paper is to introduce an open-source tool for automatic architectural smells detection for C/C++ projects, by creating an abstraction of the project and defining the concept of dependency between elements belonging to the project in order to identify architectural smells. The tool has been validated on some open-source projects with promising results.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/8498241">link</a><br><h2>Título 48: How do developers fix issues and pay back technical debt in the Apache ecosystem?</h2><h3>Autores: ['Georgios Digkas', 'Mircea Lungu', 'Paris Avgeriou', 'Alexander Chatzigeorgiou', 'Apostolos Ampatzoglou']</h3><h4>Ano: 2018</h4><p>During software evolution technical debt (TD) follows a constant ebb and flow, being incurred and paid back, sometimes in the same day and sometimes ten years later. There have been several studies in the literature investigating how technical debt in source code accumulates during time and the consequences of this accumulation for software maintenance. However, to the best of our knowledge there are no large scale studies that focus on the types of issues that are fixed and the amount of TD that is paid back during software evolution. In this paper we present the results of a case study, in which we analyzed the evolution of fifty-seven Java open-source software projects by the Apache Software Foundation at the temporal granularity level of weekly snapshots. In particular, we focus on the amount of technical debt that is paid back and the types of issues that are fixed. The findings reveal that a small subset of all issue types is responsible for the largest percentage of TD repayment and thus, targeting particular violations the development team can achieve higher benefits.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/8330205">link</a><br><h2>Título 47: A tertiary study on technical debt: Types, management strategies, research trends, and base information for practitioners</h2><h3>Autores: ['Nicolli Rios', 'Manoel Mendon{\\c{c}}a Neto', "Rodrigo Sp{\\'{\\i}}nola"]</h3><h4>Ano: 2018</h4><p>AbstractLarge software companies need to support continuous and fast delivery of customer value both in the short and long term. However, this can be hindered if both the evolution and maintenance of existing systems are hampered by Technical Debt. Although a lot of theoretical work on Technical Debt has been produced recently, its practical management lacks empirical studies. In this paper, we investigate the state of practice in several companies to understand what the cost of managing TD is, what tools are used to track TD, and how a tracking process is introduced in practice. We combined two phases: a survey involving 226 respondents from 15 organizations and an in-depth multiple case study in three organizations including 13 interviews and 79 Technical Debt issues. We selected the organizations where Technical Debt was better tracked in order to distill best practices. We found that the development time dedicated to managing Technical Debt is substantial (an average of 25 of the overall development), but mostly not systematic: only a few participants (26) use a tool, and only 7.2 methodically track Technical Debt. We found that the most used and effective tools are currently backlogs and static analyzers. By studying the approaches in the companies participating in the case study, we report how companies start tracking Technical Debt and what the initial benefits and challenges are. Finally, we propose a Strategic Adoption Model for the introduction of tracking Technical Debt in software organizations.</p><br><a href="https://www.sciencedirect.com/science/article/pii/S0950584918300946">link</a><br><h2>Título 45: Assessing technical debt in automated tests with CodeScene</h2><h3>Autores: ['Adam Tornhill']</h3><h4>Ano: 2018</h4><p>Test automation promises several advantages such as shorter lead times, higher code quality, and an executable documentation of the system's behavior. However, test automation won't deliver on those promises unless the quality of the automated test code itself is maintained, and to manually inspect the evolution of thousands of tests that change on a daily basis is impractical at best. This paper investigates how CodeScene - a tool for predictive analyses and visualizations - could be used to identify technical debt in automated test code. CodeScene combines repository mining, static code analysis, and machine learning to prioritize potential code improvements based on the most likely return on investment.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/8411742">link</a><br><h2>Título 46: Effort estimation in large-scale software development: An industrial case study</h2><h3>Autores: ['Muhammad Usman', 'Ricardo Britto', 'Lars-Ola Damm', 'Jurgen Borstler']</h3><h4>Ano: 2018</h4><p>Context: Software projects frequently incur schedule and budget overruns. Planning and estimation are particularly challenging in large and globally distributed agile projects. While software engineering researchers have been investigating effort estimation for many years to help practitioners to improve their estimation processes, there is little empirical research about effort estimation in large-scale distributed projects involving agile teams.
Objective: The objective of this paper is three-fold: i) To identify how effort estimation is carried out in large-scale distributed agile projects; ii) to analyze the accuracy of the effort estimation processes in large-scale distributed agile projects; and iii) to identify and investigate the factors that impact the accuracy of effort estimates in large-scale distributed agile projects.
Method: We performed an exploratory longitudinal case study. The data collection was operationalized through archival research and semi-structured interviews.
Results: The main findings of the studied case are: 1) A two-stage estimation process, with re-estimation at the analysis stage, improves the accuracy of the effort estimates; 2) underestimation is the dominant trend; 3) less mature teams incur larger effort overruns; 4) requirements with larger size/scope incur larger effort overruns; 5) requirements developed in multi-site settings incur larger effort overruns as compared to requirements developed in a co-located setting; 6) requirements priorities impact the accuracy of the effort estimates.
Conclusion: A two-stage effort estimation process can improve effort estimation accuracy and seems to address some of the challenges in large-scale agile software development. To improve effort estimates one needs to consider team maturity, distribution as well as requirements size and priorities.</p><br><a href="https://www.sciencedirect.com/science/article/pii/S0950584918300326">link</a><br><h2>Título 43: Identifying architectural technical debt in android applications through automated compliance checking</h2><h3>Autores: ['Roberto Verdecchia']</h3><h4>Ano: 2018</h4><p>By considering the fast pace at which mobile applications need to evolve, Architectural Technical Debt results to be a crucial yet implicit factor of success. In this research we present an approach to automatically identify Architectural Technical Debt in Android applications. The approach takes advantage of architectural guidelines extraction and modeling, architecture reverse engineering, and compliance checking. As future work, we plan to fully automate the process and empirically evaluate it via large-scale experiments.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/8543428">link</a><br><h2>Título 36: Investigating the causes of software technical debt at the architectural level</h2><h3>Autores: ['Jen Hsu']</h3><h4>Ano: 2018</h4><p>Architectural technical debt (ATD) describes the consequences of intentionally or unintentionally making architectural design decisions that compromise the internal quality of a software system. These consequences include long-term software evolution and maintenance issues that jeopardize software developer productivity. The architectural aspect of technical debt has been receiving significant interest from technical debt researchers, but many questions concerning architectural technical debt itself have yet to be answered. The main goal of this exploratory multiple-case study is to investigate architectural technical debt’s causes and accumulations at the design decision-level by examining software practitioners’ experiences with architectural technical debt and creating taxonomies that would aid software practitioners and technical debt researchers in the future. We conducted semi-structured interviews with 18 participants and an interview-style online questionnaire with 10 participants. From the data collected, we obtained 53 architectural technical debt issues in 15 non-trivial software intensive projects from eight organizations. The results of this study present two architectural technical debt taxonomies on the causes and accumulations of this issue. Then, we report our findings on current architectural technical debt management practices and practitioner experiences with architectural technical debt.</p><br><a href="https://scholar.archive.org/work/oianpmu6i5cw5bhcrtwds7rabm/access/wayback/https://open.library.ubc.ca/media/download/pdf/24/1.0372145/3">link</a><br><h2>Título 41: Towards an architectural debt index</h2><h3>Autores: ['Riccardo Roveda', 'Francesca Fontana', 'Ilaria Pigazzini', 'Marco Zanoni']</h3><h4>Ano: 2018</h4><p>Architectural technical debt can have a huge impact on software maintainability and evolution. Hence, different architectural violations, detected as architectural smells, need to be identified and refactored. In this paper, we conducted a multiple case-study on several architectural smells detected in four industrial projects. We conducted an in-depth investigation with a questionnaire, interviews and thorough inspection of the code with the practitioners. We evaluated the negative impact of the technical debt detected by the architectural smells, their difficulty to be refactored and the usefulness of the detection tool. The results show that practitioners appreciated the help of automatic detection, and that they prioritize refactoring architectural debt that causes more negative impact despite the higher refactoring effort.</p><br><a href="https://link.springer.com/chapter/10.1007/978-3-030-00761-4_21">link</a><br><h2>Título 40: Identifying and prioritizing architectural debt through architectural smells: a case study in a large software company</h2><h3>Autores: ['Antonio Martini', 'Francesca Fontana', 'Andrea Biaggi', 'Riccardo Roveda']</h3><h4>Ano: 2018</h4><p>Architectural technical debt can have a huge impact on software maintainability and evolution. Hence, different architectural violations, detected as architectural smells, need to be identified and refactored. In this paper, we conducted a multiple case-study on several architectural smells detected in four industrial projects. We conducted an in-depth investigation with a questionnaire, interviews and thorough inspection of the code with the practitioners. We evaluated the negative impact of the technical debt detected by the architectural smells, their difficulty to be refactored and the usefulness of the detection tool. The results show that practitioners appreciated the help of automatic detection, and that they prioritize refactoring architectural debt that causes more negative impact despite the higher refactoring effort.</p><br><a href="https://link.springer.com/chapter/10.1007/978-3-030-00761-4_21">link</a><br><h2>Título 39: Managing architectural technical debt: A unified model and systematic literature review</h2><h3>Autores: ['Terese Besker', 'Antonio Martini', 'Jan Bosch']</h3><h4>Ano: 2018</h4><p>Large Software Companies need to support the continuous and fast delivery of customer value in both the short and long term. However, this can be impeded if the evolution and maintenance of existing systems is hampered by what has been recently termed Technical Debt (TD). Specifically, Architectural TD has received increased attention in the last few years due to its significant impact on system success and, left unchecked, it can cause expensive repercussions. It is therefore important to understand the underlying factors of architectural TD. With this as background, there is a need for a descriptive model to illustrate and explain different architectural TD issues. The aim of this study is to synthesize and compile research efforts with the goal of creating new knowledge with a specific interest in the architectural TD field. The contribution of this paper is the presentation of a novel descriptive model, providing a comprehensive interpretation of the architectural TD phenomenon. This model categorizes the main characteristics of architectural TD and reveals their relations. The results show that, by using this model, different stakeholders could increase the system's success rate, and lower the rate of negative consequences, by raising awareness about architectural TD.</p><br><a href="https://www.sciencedirect.com/science/article/pii/S0164121217302121">link</a><br><h2>Título 38: Exploring the relationship between software modularity and technical debt</h2><h3>Autores: ['Peggy Skiada', 'Apostolos Ampatzoglou', 'Elvira-Maria Arvanitou', 'Alexander Chatzigeorgiou', 'Ioannis Stamelos']</h3><h4>Ano: 2018</h4><p>Modularity is one of the key principles of software design. In order for a software system to be modular, it should be organized into modules that are highly coherent internally, whereas at the same time as independent from other modules as possible. In this paper we explore coupling and cohesion metrics at the software package level-i.e., one of most basic levels of software functional decomposition in object-oriented (OO) systems, with the aim of investigating their relation to the technical debt of each package. Current state-of-the-art tools in TD measurement are working on the source code level, and the extent to which they can unveil limitations at the architecture level (e.g., violations of the modularity principle), has not been explored so far. To achieve this goal, we conducted a case study on 1,200 packages retrieved from 20 well-known open source software projects. The results of the study suggested that current measures of technical debt are able to identify / predict modules that lack modularity, and therefore suffer from Architectural Technical Debt (ATD). The results of the study are discussed both from the practitioners' and re-searchers' point of view.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/8498239">link</a><br><h2>Título 37: A semi-automated framework for the identification and estimation of architectural technical debt: A comparative case-study on the modularization of a software component</h2><h3>Autores: ['Antonio Martini', 'Erik Sikander', 'Niel Madlani']</h3><h4>Ano: 2018</h4><p>Context
Research and industry's attention has been focusing on developing systems that enable fast time to market in the short term, but would assure a sustainable delivery of business value and maintenance operations in the long run. A related phenomenon has been identified in Architectural Technical Debt: if the system architecture is sub-optimal for long-term business goals, it might need to be refactored. A key property of the system assuring long-term goals is its modularity, or else the degree to which components are decoupled: such property allows the product to be evolved without costly changes pervading the whole system. However, understanding the business benefits of refactoring to achieve modularity is not trivial, especially for large refactorings involving substantial architectural changes.
Objective
The aim of this study was to develop a technique to identify Architectural Technical Debt in the form of a non-modularized component and to quantify the convenience of its repayment.
Method
We have conducted a single, embedded case study in a large company, comparing a component before and after it was refactored to achieve modularity. We have developed a holistic framework for the semi-automated identification and estimation of Architectural Technical Debt in the form of non-modularized components. We then evaluate the technique reporting a comparative study of the difference in maintenance and development costs in two coexisting systems, one including the refactored component and one including the non-refactored one.
Results
The main contributions are a measurement system for the identification of the Architectural Technical Debt according to the stakeholders’ goals, a mathematical relationship for calculating and quantifying its interest in terms of extra-effort spent in additional development and maintenance, and an overall decision framework to assess the benefit of refactoring. We also report context-specific results that show the estimated benefits of refactoring the specific case of Architectural Technical Debt.
Conclusion
We found that it is possible to identify this kind of Architectural Technical Debt and to quantify its repayment convenience. Thanks to the developed framework, it was possible to estimate that the Architectural Technical Debt present in the component was causing substantial continuous extra-effort, and that the modularization would be repaid in several months of development and maintenance.</p><br><a href="https://www.sciencedirect.com/science/article/pii/S095058491630355X">link</a><br><h2>Título 42: Code smells for model-view-controller architectures</h2><h3>Autores: ['Mauricio Aniche', 'Gabriele Bavota', 'Christoph Treude', 'Marco Gerosa', 'Arie Deursen']</h3><h4>Ano: 2018</h4><p>Previous studies have shown the negative effects that low-quality code can have on maintainability proxies, such as code change- and defect-proneness. One of the symptoms of low-quality code are code smells, defined as sub-optimal implementation choices. While this definition is quite general and seems to suggest a wide spectrum of smells that can affect software systems, the research literature mostly focuses on the set of smells defined in the catalog by Fowler and Beck, reporting design issues that can potentially affect any kind of system, regardless of their architecture (e.g., Complex Class). However, systems adopting a specific architecture (e.g., the Model-View-Controller pattern) can be affected by other types of poor practices that only manifest themselves in the chosen architecture. We present a catalog of six smells tailored to MVC applications and defined by surveying/interviewing 53 MVC developers. We validate our catalog from different perspectives. First, we assess the relationship between the defined smells and the code change- and defect-proneness. Second, we investigate when these smells are introduced and how long they survive. Third, we survey 21 developers to verify their perception of the defined smells. Fourth, since our catalog has been mainly defined together with developers adopting a specific Java framework in their MVC applications (e.g., Spring), we interview four expert developers working with different technologies for the implementation of their MVC applications to check the generalizability of our catalog. The achieved results show that the defined Web MVC smells (i) more often than not, have more chances of being subject to changes and defects, (ii) are mostly introduced when the affected file (i.e., the file containing the smell) is committed for the first time in the repository and survive for long time in the system, (iii) are perceived by developers as severe problems, and (iv) generalize to other languages/frameworks.</p><br><a href="https://link.springer.com/article/10.1007/s10664-017-9540-2">link</a><br><h2>Título 59: Uma ferramenta para monitoramento de entropia de mudança e sua relação com métricas de software</h2><h3>Autores: ['Tiago Umemura']</h3><h4>Ano: 2017</h4><p>Contexto: A entropia de mudança é uma medida para indicar o quanto um software sofre alterações em um determinado período de tempo. Estudos mostraram que o aumento da entropia pode causar desordem no processo de desenvolvimento podendo levar ao aumento no número de defeitos do software. Dado esse contexto, não existem ferramentas que ofereçam suporte para monitoramento da relação entre entropia e diferentes métricas de software, como por exemplo, número de autores que modificaram um arquivo, número de commits, authorship e ownership. Objetivo: Implementar e avaliar uma ferramenta que possibilite o monitoramento da entropia e das métricas de softwares de projetos armazenados no Github, para ajudar os desenvolvedores no gerenciamento de projeto. Ferramenta: A ferramenta é dividida em coleta de dados, cálculo da entropia e das métricas, cálculo da correlação de Spearman e visualização de dados. Na coleta de dados, os dados são extraídos por meio da API Github e em seguida é realizado o cálculo da entropia, métricas de software e da correlação Spearman entre a entropia e as métricas. Na etapa de visualização de dados, os valores da entropia de mudança e das métricas de software são exibidos utilizando gráficos de Treemap, Heat Map e séries temporais. A ferramenta foi avaliada por meio da análise das visualizações geradas sobre o histórico do projeto Angular. Resultados: Na análise da ferramenta, foi possível localizar arquivos mais relevantes do projeto, medindo o valor de entropia de mudança e gerando a visualização de Treemaps em diferentes períodos. Calculando a correlação de Spearman e analisando a visualização de Heat Map em diferentes períodos foi possível observar quais métricas apresentam maior nível de correlação com o valor de entropia dos arquivos. Conclusões: Foi concluído que a ferramenta pode ser utilizada para encontrar os arquivos que merecem maior atenção dos desenvolvedores no projeto, devido ao valor alto da entropia e das métricas correlaciondas a entropia.</p><br><a href="http://repositorio.utfpr.edu.br/jspui/handle/1/6027">link</a><br><h2>Título 66: Source code metrics: A systematic mapping study</h2><h3>Autores: ['Alberto Nu{\\~n}ez-Varela', "H{\\'e}ctor P{\\'e}rez-Gonzalez", "Francisco Mart{\\'\\i}nez-Perez", 'Carlos Soubervielle-Montalvo']</h3><h4>Ano: 2017</h4><p>Context
Source code metrics are essential components in the software measurement process. They are extracted from the source code of the software, and their values allow us to reach conclusions about the quality attributes measured by the metrics.
Objectives
This paper aims to collect source code metrics related studies, review them, and perform an analysis, while providing an overview on the current state of source code metrics and their current trends.
Method
A systematic mapping study was conducted. A total of 226 studies, published between the years 2010 and 2015, were selected and analyzed.
Results
Almost 300 source code metrics were found. Object oriented programming is the most commonly studied paradigm with the Chidamber and Kemerer metrics, lines of code, McCabe's cyclomatic complexity, and number of methods and attributes being the most used metrics. Research on aspect and feature oriented programming is growing, especially for the current interest in programming concerns and software product lines.
Conclusions
Object oriented metrics have gained much attention, but there is a current need for more studies on aspect and feature oriented metrics. Software fault prediction, complexity and quality assessment are recurrent topics, while concerns, big scale software and software product lines represent current trends.</p><br><a href="https://www.sciencedirect.com/science/article/pii/S0164121217300663">link</a><br><h2>Título 65: The Pricey Bill of Technical Debt: When and by Whom will it be Paid?</h2><h3>Autores: ['T. Besker', 'A. Martini', 'J. Bosch']</h3><h4>Ano: 2017</h4><p>Software companies need to support continuous and fast delivery of customer value both in short and a long-term perspective. However, this can be hindered by evolution limitations and high maintenance efforts due to internal software quality issues by what is described as Technical Debt. Although significant theoretical work has been undertaken to describe the negative effects of Technical Debt, these studies tend to have a weak empirical basis and often lack quantitative data. The aim of this study is to estimate wasted time, caused by the Technical Debt interest during the software life-cycle. This study also investigates how practitioners perceive and estimate the impact of the negative consequences due to Technical Debt during the software development process. This paper reports the results of both an online web-survey provided quantitative data from 258 participants and follow-up interviews with 32 industrial software practitioners. The importance and originality of this study contributes and provides novel insights into the research on Technical Debt by quantifying the perceived interest and the negative effects it has on the software development life-cycle. The findings show that on average, 36 percent of all development time is estimated to be wasted due to Technical Debt; Complex Architectural Design and Requirement Technical Debt generates most negative effect; and that most time is wasted on understanding and/or measuring the Technical Debt. Moreover, the analysis of the professional roles and the age of the software system in the survey revealed that different roles are affected differently and that the consequences of Technical Debt are also influenced by the age of the software system.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/8094405">link</a><br><h2>Título 64: An Open Tool for Assisting in Technical Debt Management</h2><h3>Autores: ['Carlos Fernandez-Sanchez', 'Hector Humanes', 'Juan Garbajosa', 'Jessica Diaz']</h3><h4>Ano: 2017</h4><p>Technical debt monitoring is one of the activities that have to be performed in technical debt management. To do that, there are different techniques that can be used to estimate technical debt and different tools that implement those different techniques. This paper presents TEDMA Tool, a tool for monitoring technical debt over the software evolution and that it is open to integrate third party tools. TEDMA is based on the analysis of source code repositories and is useful for researching using empirical data extracted from software projects. Currently, it is been used to analyze big projects in the execution of several case studies. The expected evolution of TEDMA will make the tool useful for software development industry.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/8051378">link</a><br><h2>Título 63: Impact of architectural technical debt on daily software development work—a survey of software practitioners</h2><h3>Autores: ['Terese Besker', 'Antonio Martini', 'Jan Bosch']</h3><h4>Ano: 2017</h4><p>The negative consequences of Technical Debt is an area of increasing interest, and more specifically the Architectural aspects of it have received increased attention in the last few years. Besides the negative effects of Architectural Technical Debt on the overall software product quality in terms of hindering evolution and causing high maintenance costs, Architectural Technical Debt also has a significant negative impact on software practitioners' daily work. Although a great deal of theoretical work on Architectural Technical Debt has been undertaken, there is a lack of empirical studies that examine the negative effects of Architectural Technical Debt during the software development lifecycle. The aim of this study is to investigate how practitioners perceive and estimate the impact of Architectural Technical Debt during the software development process. This paper reports the results of an online web survey providing quantitative data from 258 participants. The contribution of this paper is threefold: First, it shows that practitioners experience that the Architectural type of Technical Debt has the highest negative impact on daily software development work. Secondly, we provide evidence that does not support the commonly held belief that Architectural Technical Debt increases with the age of the software. Thirdly, we show that despite different responsibilities and working tasks of software professionals, Architectural Technical Debt negatively affects all roles without any significant difference between the roles.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/8051360">link</a><br><h2>Título 62: On the interest of architectural technical debt: Uncovering the contagious debt phenomenon</h2><h3>Autores: ['Antonio Martini', 'Jan Bosch']</h3><h4>Ano: 2017</h4><p>A known problem in large software companies is to balance the prioritization of short-term and long-term business goals. As an example, architecture suboptimality (Architectural Technical Debt), incurred to deliver fast, might hinder future feature development. However, some technical debt generates more interest to be paid than other. We conducted a multi-phase, multiple-case embedded case study comprehending 9 sites at 6 large international software companies. We have investigated which architectural technical debt items generate more interest , how the interest occurs during software development and which costly extra-activities are triggered as a result. We presented a taxonomy of the most dangerous items identified during the qualitative investigation and a model of their effects that can be used for prioritization, for further investigation and as a quality model for extracting more precise and context-specific metrics. We found that some architectural technical debt items are contagious, causing the interest to be not only fixed, but potentially compound, which leads to the hidden growth of interest (possibly exponential). We found important factors to be monitored to refactor the debt before it becomes too costly. Instances of these phenomena need to be identified and stopped before the development reaches a crises.</p><br><a href="https://onlinelibrary.wiley.com/doi/full/10.1002/smr.1877">link</a><br><h2>Título 61: Managing the requirements flow from strategy to release in large-scale agile development: a case study at Ericsson</h2><h3>Autores: ['V.T. Heikkila', 'M. Paasivaara', 'C. Lasssenius', 'D. Damian', 'C. Engblom']</h3><h4>Ano: 2017</h4><p>In a large organization, informal communication and simple backlogs are not sufficient for the management of requirements and development work. Many large organizations are struggling to successfully adopt agile methods, but there is still little scientific knowledge on requirements management in large-scale agile development organizations. We present an in-depth study of an Ericsson telecommunications node development organization which employs a large scale agile method to develop telecommunications system software. We describe how the requirements flow from strategy to release, and related benefits and problems. Data was collected by 43 interviews, which were analyzed qualitatively. The requirements management was done in three different processes, each of which had a different process model, purpose and planning horizon. The release project management process was plan-driven, feature development process was continuous and implementation management process was agile. The perceived benefits included reduced development lead time, increased flexibility, increased planning efficiency, increased developer motivation and improved communication effectiveness. The recognized problems included difficulties in balancing planning effort, overcommitment, insufficient understanding of the development team autonomy, defining the product owner role, balancing team specialization, organizing system-level work and growing technical debt. The study indicates that agile development methods can be successfully employed in organizations where the higher level planning processes are not agile. Combining agile methods with a flexible feature development process can bring many benefits, but large-scale software development seems to require specialist roles and significant coordination effort. © 2016, The Author(s).</p><br><a href="https://link.springer.com/article/10.1007/s10664-016-9491-z">link</a><br><h2>Título 60: Empirical study on refactoring large-scale industrial systems and its effects on maintainability</h2><h3>Autores: ["G{\\'a}bor Sz{\\H{o}}ke", "G{\\'a}bor Antal", 'Csaba Nagy', 'Rudolf Ferenc', "Tibor Gyim{\\'o}thy"]</h3><h4>Ano: 2017</h4><p>Software evolves continuously, it gets modified, enhanced, and new requirements always arise. If we do not spend time occasionally on improving our source code, its maintainability will inevitably decrease. The literature tells us that we can improve the maintainability of a software system by regularly refactoring it. But does refactoring really increase software maintainability? Can it happen that refactoring decreases the maintainability? Empirical studies show contradicting answers to these questions and there have been only a few studies which were performed in a large-scale, industrial context. In our paper, we assess these questions in an in vivo context, where we analyzed the source code and measured the maintainability of 6 large-scale, proprietary software systems in their manual refactoring phase. We analyzed 2.5 million lines of code and studied the effects on maintainability of 315 refactoring commits which fixed 1273 coding issues. We found that single refactorings only make a very little difference (sometimes even decrease maintainability), but a whole refactoring period, in general, can significantly increase maintainability, which can result not only in the local, but also in the global improvement of the code.</p><br><a href="https://www.sciencedirect.com/science/article/pii/S0164121216301558">link</a><br><h2>Título 58: Arcan: A tool for architectural smells detection</h2><h3>Autores: ['Francesca Fontana', 'Ilaria Pigazzini', 'Riccardo Roveda', 'Damian Tamburri', 'Marco Zanoni', 'Elisabetta Di Nitto']</h3><h4>Ano: 2017</h4><p>Code smells are sub-optimal coding circumstances such as blob classes or spaghetti code - they have received much attention and tooling in recent software engineering research. Higher-up in the abstraction level, architectural smells are problems or sub-optimal architectural patterns or other design-level characteristics. These have received significantly less attention even though they are usually considered more critical than code smells, and harder to detect, remove, and refactor. This paper describes an open-source tool called Arcan developed for the detection of architectural smells through an evaluation of several different architecture dependency issues. The detection techniques inside Arcan exploit graph database technology, allowing for high scalability in smells detection and better management of large amounts of dependencies of multiple kinds. In the scope of this paper, we focus on the evaluation of Arcan results carried out with real-life software developers to check if the architectural smells detected by Arcan are really perceived as problems and to get an overall usefulness evaluation of the tool.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/7958506">link</a><br><h2>Título 57: Compiling static software metrics for reliability and maintainability from GitHub repositories</h2><h3>Autores: ['Jeremy Ludwig', 'Steven Xu', 'Frederick Webber']</h3><h4>Ano: 2017</h4><p>This paper identifies a small, essential set of static software code metrics linked to the software product quality characteristics of reliability and maintainability and to the most commonly identified sources of technical debt. A plug-in is created for the Understand code visualization and static analysis tool that calculates and aggregates the metrics. The plug-in produces a high-level interactive html report as well as developer-level information needed to address quality issues using Understand. A script makes use of Git, Understand, and the plug-in to compile results for a list of GitHub repositories into a single file. The primary contribution of this work is to describe an open-source plug-in to measure and visualize architectural complexity based on the propagation cost and core size metrics, which are not currently found in other tools. The plug-in should be useful to researchers and practitioners interested in these two metrics and as an expedient starting point to experimentation with metric collection and aggregation for groups of GitHub repositories. The plug-in was developed as a first step in an ongoing project aimed at applying case-based reasoning to the issue of software product quality.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/8122569">link</a><br><h2>Título 56: Taxonomies in software engineering: A systematic mapping study and a revised taxonomy development method</h2><h3>Autores: ['Muhammad Usman', 'Ricardo Britto', 'J{\\"u}rgen B{\\"o}rstler', 'Emilia Mendes']</h3><h4>Ano: 2017</h4><p>Context: Software Engineering (SE) is an evolving discipline with new subareas being continuously developed and added. To structure and better understand the SE body of knowledge, taxonomies have been proposed in all SE knowledge areas.
Objective: The objective of this paper is to characterize the state-of-the-art research on SE taxonomies.
Method: A systematic mapping study was conducted, based on 270 primary studies.
Results: An increasing number of SE taxonomies have been published since 2000 in a broad range of venues, including the top SE journals and conferences. The majority of taxonomies can be grouped into the following SWEBOK knowledge areas: construction (19.55%), design (19.55%), requirements (15.50%) and maintenance (11.81%). Illustration (45.76%) is the most frequently used approach for taxonomy validation. Hierarchy (53.14%) and faceted analysis (39.48%) are the most frequently used classification structures. Most taxonomies rely on qualitative procedures to classify subject matter instances, but in most cases (86.53%) these procedures are not described in sufficient detail. The majority of the taxonomies (97%) target unique subject matters and many taxonomy-papers are cited frequently. Most SE taxonomies are designed in an ad-hoc way. To address this issue, we have revised an existing method for developing taxonomies in a more systematic way.

Conclusion: There is a strong interest in taxonomies in SE, but few taxonomies are extended or revised. Taxonomy design decisions regarding the used classification structures, procedures and descriptive bases are usually not well described and motivated.</p><br><a href="https://www.sciencedirect.com/science/article/pii/S0950584917300472">link</a><br><h2>Título 55: Using Naming Patterns for Identifying Architectural Technical Debt</h2><h3>Autores: ['Paul Carpio']</h3><h4>Ano: 2017</h4><p>Hasty software development can produce immediate implementations with source code unnecessarily complex and hardly readable. These small kinds of software decay generate a technical debt that could be big enough to seriously affect future maintenance activities. This work presents an analysis technique for identifying architectural technical debt related to non-uniformity of naming patterns; the technique is based on term frequency over package hierarchies. The proposal has been evaluated on projects of two popular organizations, Apache and Eclipse. The results have shown that most of the projects have frequent occurrences of the proposed naming patterns, and using a graph model and aggregated data could enable the elaboration of simple queries for debt identification. The technique has features that favor its applicability on emergent architectures and agile software development.</p><br><a href="http://repositorio.ulasalle.edu.pe/handle/20.500.12953/62">link</a><br><h2>Título 54: Revealing social debt with the CAFFEA framework: An antidote to architectural debt</h2><h3>Autores: ['Antonio Martini', 'Jan Bosch']</h3><h4>Ano: 2017</h4><p>Large software companies need a well-managed Software Architecture to support continuous and fast delivery of customer value both in the short and long term. However, this can be hindered if both evolution and maintenance of existing systems are hampered by Architectural Technical Debt. To avoid the accumulation and the costly consequences of ATD, it is critical that the responsibilities to minimize it are well understood and shared in a large software organization. In this paper, we argue that an organizational model, based on a well validated framework such as CAFFEA, can be used to reveal sub-optimalities in the social structure of the organization: in other words, it can reveal Social Debt. Such sub-optimality, according to previous work, leads to the accumulation of ATD. In conclusion, using the CAFFEA framework as an organizational analysis tool, can reveal weak spots (Social Debt) in the organization and can help preventing costly ATD and its consequences.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/7958479">link</a><br><h2>Título 53: Requirements volatility in software architecture design: an exploratory case study</h2><h3>Autores: ['Sanja Aaramaa', 'Sandun Dasanayake', 'Markku Oivo', 'Jouni Markkula', 'Samuli Saukkonen']</h3><h4>Ano: 2017</h4><p>Requirements volatility is a major issue in software (SW) development, causing problems such as project delays and cost overruns. Even though there is a considerable amount of research related to requirement volatility, the majority of it is inclined toward project management aspects. The relationship between SW architecture design and requirements volatility has not been researched widely, even though changing requirements may for example lead to higher defect density during testing. An exploratory case study was conducted to study how requirements volatility affects SW architecture design. Fifteen semi-structured, thematic interviews were conducted in the case company, which provides the selection of software products for business customers and consumers. The research revealed the factors, such as requirements uncertainty and dynamic business environment, causing requirements volatility in the case company. The study identified the challenges that requirements volatility posed to SW architecture design, including scheduling and architectural technical debt. In addition, this study discusses means of mitigating the factors that cause requirements volatility and addressing the challenges posed by requirements volatility. SW architects are strongly influenced by requirement volatility. Thus understanding the factors causing requirements volatility as well as means to mitigate the challenges has high industrial relevance.</p><br><a href="https://dl.acm.org/doi/abs/10.1145/3084100.3084105">link</a><br><h2>Título 52: Estimating Architectural Technical Debt: A design research</h2><h3>Autores: ['Gustav Dahl']</h3><h4>Ano: 2017</h4><p>Technical debt(TD) and the sub-category architectural technical debt (ATD) are two software related buzzwords frequently used in both academia and in the software industry. The purpose of these terms is to make it easier to understand that a software decision might lead to an expected or unexpected consequence that could have an impact in the long-run. Hence, the TD level in a project needs to be under control. However, the common approach towards refactoring of a TD is to handle it when it is too late and a crisis has emerged due to its presence. In order to solve this and make the stakeholders able to determine when a TD should be refactored a tool has been developed. This tool incorporates the newly developed AnaConDebt model, which is an ATD refactoring decision model. The outcome from building and evaluating this proof-of-concept is that there is potential for such a tool but it is not yet there. The underlying model needs to be further developed incorporating more info used by the industry.</p><br><a href="https://odr.chalmers.se/handle/20.500.12380/253719">link</a><br><h2>Título 76: Developing Processes to Increase Technical Debt Visibility and Manageability {\textendash} An Action Research Study in Industry</h2><h3>Autores: ['Jesse Yli-Huumo', 'Andrey Maglyas', 'Kari Smolander', 'Johan Haller', 'Hannu Törnroos']</h3><h4>Ano: 2016</h4><p>The knowledge about technical debt and its management has increased in recent years. The interest of academia and industry has generated many viewpoints on technical debt. Technical debt management consists of technical and organizational aspects, which make it a challenge in software development. To increase technical debt visibility and manageability, new processes must be developed and thoroughly empirically tested for their applicability. In this paper, we use the action research methodology to design processes for identification, documentation, and prioritization of technical debt. Our partner in this research is a large Nordic IT company Tieto, currently in a need for new ways to improve their technical debt management. The results include a set of processes and templates that were successfully used to identify and document technical debt. The identified technical debt items were later prioritized based on evaluation by Tieto employees. Tieto was able to create a prioritized technical debt backlog, which is now used for reduction activities to create a healthy and sustainable product for the future.</p><br><a href="https://link.springer.com/chapter/10.1007/978-3-319-49094-6_24">link</a><br><h2>Título 84: Challenges and success factors for large-scale agile transformations: A systematic literature review</h2><h3>Autores: ['K. Dikert', 'M. Paasivaara', 'C. Lassenius']</h3><h4>Ano: 2016</h4><p>Agile methods have become an appealing alternative for companies striving to improve their performance, but the methods were originally designed for small and individual teams. This creates unique challenges when introducing agile at scale, when development teams must synchronize their activities, and there might be a need to interface with other organizational units. In this paper we present a systematic literature review on how agile methods and lean software development has been adopted at scale, focusing on reported challenges and success factors in the transformation. We conducted a systematic literature review of industrial large-scale agile transformations. Our keyword search found 1875 papers. We included 52 publications describing 42 industrial cases presenting the process of taking large-scale agile development into use. Almost 90{\%} of the included papers were experience reports, indicating a lack of sound academic research on the topic. We identified 35 reported challenges grouped into nine categories, and 29 success factors, grouped into eleven categories. The most salient success factor categories were management support, choosing and customizing the agile model, training and coaching, and mindset and alignment.</p><br><a href="https://www.sciencedirect.com/science/article/pii/S0164121216300826">link</a><br><h2>Título 83: How do software development teams manage technical debt? An empirical study</h2><h3>Autores: ['J. Yli-Huumo', 'A. Maglyas', 'K. Smolander']</h3><h4>Ano: 2016</h4><p>Technical debt (TD) is a metaphor for taking shortcuts or workarounds in technical decisions to gain short-term benefit in time-to-market and earlier software release. In this study, one large software development organization is investigated to gather empirical evidence related to the concept of technical debt management (TDM). We used the exploratory case study method to collect and analyze empirical data in the case organization by interviewing a total of 25 persons in eight software development teams. We were able to identify teams where the current strategy for TDM was only to fix TD when necessary, when it started to cause too much trouble for development. We also identified teams where the management had a systematic strategy to identify, measure and monitor TD during the development process. It seems that TDM can be associated with a similar maturity concept as software development in general. Development teams may raise their maturity by increasing their awareness and applying more advanced processes, techniques and tools in TDM. TDM is an essential part of sustainable software development, and companies have to find right approaches to deal with TD to produce healthy software that can be developed and maintained in the future. © 2016 The Authors</p><br><a href="https://www.sciencedirect.com/science/article/pii/S016412121630053X">link</a><br><h2>Título 82: Global software engineering: Evolution and trends</h2><h3>Autores: ['Christof Ebert', 'Marco Kuhrmann', 'Rafael Prikladnicki']</h3><h4>Ano: 2016</h4><p>Professional software products and IT systems and services today are developed mostly by globally distributed teams, projects, and companies. Successfully orchestrating Global Software Engineering (GSE) has become the major success factor both for organizations and practitioners. Yet, more than a half of all distributed projects does not achieve the intended objectives and is canceled. This paper summarizes experiences from academia and industry in a way to facilitate knowledge and technology transfer. It is based on an evaluation of 10 years of research, and industry collaboration and experience reported at the IEEE International Conference on Software Engineering (ICGSE) series. The outcomes of our analysis show GSE as a field highly attached to industry and, thus, a considerable share of ICGSE papers address the transfer of Software Engineering concepts and solutions to the global stage. We found collaboration and teams, processes and organization, sourcing and supplier management, and success factors to be the topics gaining the most interest of researchers and practitioners. Beyond the analysis of the past conferences, we also look at current trends in GSE to motivate further research and industrial collaboration.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/7577432">link</a><br><h2>Título 81: Architecture viewpoints for documenting architectural technical debt</h2><h3>Autores: ['Zengyang Li', 'Peng Liang', 'Paris Avgeriou']</h3><h4>Ano: 2016</h4><p>Technical debt (TD) has attracted an increasing interest from researchers and practitioners in the software engineering domain. Currently, most approaches to managing TD focus on dealing with TD at source code level, while few methods deal with TD at architecture level. If architectural technical debt (ATD) is not effectively managed in the architecting process, the knowledge about ATD is not made available to involved stakeholders and the impact of ATD is not considered during architecture decision-making. Thus, the system’s maintainability and evolvability can be intentionally or unintentionally compromised. As a result, architectures are costly to maintain and new features are difficult to introduce. To facilitate the management of ATD, it needs to be documented so that it becomes explicit to stakeholders. To this end, we propose a set of architecture viewpoints related to ATD (ATD viewpoints in short). Each viewpoint frames a number of concerns related to ATD. These ATD viewpoints together help to get a comprehensive understanding of ATD in a software system, thereby providing support for architecture decision-making. To evaluate the effectiveness of the ATD viewpoints in documenting ATD, we conducted a case study in a large telecommunications company. The results of this case study show that the documented ATD views can effectively facilitate the documentation of ATD. Specifically, the ATD viewpoints are relatively easy to understand; it takes an acceptable amount of effort to document ATD using the ATD viewpoints; and the documented ATD views are useful for stakeholders to understand the ATD in the software project.</p><br><a href="https://www.sciencedirect.com/science/article/pii/B9780128023013000053">link</a><br><h2>Título 80: Estimating and quantifying the benefits of refactoring to improve a component modularity: a case study</h2><h3>Autores: ['Antonio Martini', 'Erik Sikander', 'Niel Medlani']</h3><h4>Ano: 2016</h4><p>In recent years, research and industry's attention has been focused on maintaining a system that would both decrease time to market in the short term and assure a sustainable feature output and smooth maintenance operations in the long run. A related phenomenon has been identified in Architectural Technical Debt: if the system architecture is sub-optimal for long-term business goals, it needs to be refactored. A key property of the system assuring long-term goals consists on modularity, or else the ability to decouple different components: such property allows the product to be evolved without costly changes pervading the whole system. However, understanding the business benefits of refactoring to achieve modularity is not trivial, especially for large refactorings involving substantial architectural changes. We have conducted a case study in a large company, analyzing a case of refactoring a component to achieve modularity. We report a comparative study of a refactored against a non-refactored component. We found that the modularization would be repaid in several months of development and maintenance. We present a method to calculate the effort saved by the modularization and an equation for calculating and quantifying the development and maintenance benefits of refactoring.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/7592783">link</a><br><h2>Título 79: An empirically developed method to aid decisions on architectural technical debt refactoring: AnaConDebt</h2><h3>Autores: ['Antonio Martini', 'Jan Bosch']</h3><h4>Ano: 2016</h4><p>Architectural Technical Debt is regarded as sub-optimal architectural solutions that need to be refactored in order to avoid the payment of a costly interest in the future. However, decisions on if and when to refactor architecture are extremely important and difficult to take, since changing software at the architectural level is quite expensive. Therefore it is important, for software organizations, to have methods and tools that aid architects and managers to understand if Architecture Technical Debt will generate a costly and growing interest to be paid or not. Current knowledge, especially empirically developed and evaluated, is quite scarce. In this paper we developed and evaluated a method, AnaConDebt, by analyzing, together with several practitioners, 12 existing cases of Architecture Debt in 6 companies. The method has been refined several times in order to be useful and effective in practice. We also report the evaluation of the method with a final case, for which we present anonymized results and subsequent refactoring decisions. The method consists of several components that need to be analyzed, combining the theoretical Technical Debt framework and the practical experience of the practitioners, in order to identify the key factors involved in the growth of interest. The output of the method shows summarized indicators that visualizes the factors in a useful way for the stakeholders. This analysis aids the practitioners in deciding on if and when to refactor Architectural Technical Debt items. The method has been evaluated and has been proven useful to support the architects into systematically analyze and decide upon a case.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/7883286">link</a><br><h2>Título 78: Experiences from measuring learning and performance in large-scale distributed software development</h2><h3>Autores: ['Ricardo Britto', 'Darja {\\v{S}}mite', 'Lars-Ola Damm']</h3><h4>Ano: 2016</h4><p>Background: Developers and development teams in large-scale software development are often required to learn continuously. Organizations also face the need to train and support new developers and teams on-boarded in ongoing projects. Although learning is associated with performance improvements, experience shows that training and learning does not always result in a better performance or significant improvements might take too long.
Aims: In this paper, we report our experiences from establishing an approach to measure learning results and associated performance impact for developers and teams in Ericsson.
Method: Experiences reported herein are a part of an exploratory case study of an on-going large-scale distributed project in Ericsson. The data collected for our measurements included archival data and expert knowledge acquired through both unstructured and semi-structured interviews. While performing the measurements, we faced a number of challenges, documented in the form of lessons learned.
Results: We aggregated our experience in eight lessons learned related to collection, preparation and analysis of data for further measurement of learning potential and performance in large-scale distributed software development.
Conclusions: Measuring learning and performance is a challenging task. Major problems were related to data inconsistencies caused by, among other factors, distributed nature of the project. We believe that the documented experiences shared herein can help other researchers and practitioners to perform similar measurements and overcome the challenges of large-scale distributed software projects, as well as proactively address these challenges when establishing project measurement programs.</p><br><a href="https://dl.acm.org/doi/abs/10.1145/2961111.2962636">link</a><br><h2>Título 77: Software architects in large-scale distributed projects: An Ericsson case study</h2><h3>Autores: ['Ricardo Britto', 'Darja Smite', 'Lars-Ola Damm']</h3><h4>Ano: 2016</h4><p>Software architects are key assets for successful development projects. However, not much research has investigated the challenges they face in large-scale distributed projects. So, researchers investigated how architects at Ericsson were organized, their roles and responsibilities, and the effort they spent guarding and governing a large-scale legacy product developed by teams at multiple locations. Despite recent trends such as microservices and agile development, Ericsson had to follow a more centralized approach to deal with the challenges of scale, distribution, and monolithic architecture of a legacy software product. So, the architectural decisions were centralized to a team of architects. The team extensively used code reviews to not only check the code's state but also reveal defects that could turn into maintainability problems. The study results also suggest that the effort architects spend designing architecture, guarding its integrity and evolvability, and mentoring development teams is directly related to team maturity. In addition, significant investment is needed whenever new teams and locations are onboarded.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/7725230">link</a><br><h2>Título 68: Automatic detection of instability architectural smells</h2><h3>Autores: ['Francesca Fontana', 'Ilaria Pigazzini', 'Riccardo Roveda', 'Marco Zanoni']</h3><h4>Ano: 2016</h4><p>Code smells represent well known symptoms of problems at code level, and architectural smells can be seen as their counterpart at architecture level. If identified in a system, they are usually considered more critical than code smells, for their effect on maintainability issues. In this paper, we introduce a tool for the detection of architectural smells that could have an impact on the stability of a system. The detection techniques are based on the analysis of dependency graphs extracted from compiled Java projects and stored in a graph database. The results combine the information gathered from dependency and instability metrics to identify flaws hidden in the software architecture. We also propose some filters trying to avoid possible false positives.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/7816489">link</a><br><h2>Título 75: Exploring the costs of technical debt management – a case study</h2><h3>Autores: ['Y. Guo', 'R.O. Spinola', 'C. Seaman']</h3><h4>Ano: 2016</h4><p>Technical debt is a metaphor for delayed software maintenance tasks. Incurring technical debt may bring short-term benefits to a project, but such benefits are often achieved at the cost of extra work in future, analogous to paying interest on the debt. Currently technical debt is managed implicitly, if at all. However, on large systems, it is too easy to lose track of delayed tasks or to misunderstand their impact. Therefore, we have proposed a new approach to managing technical debt, which we believe to be helpful for software managers to make informed decisions. In this study we explored the costs of the new approach by tracking the technical debt management activities in an on-going software project. The results from the study provided insights into the impact of technical debt management on software projects. In particular, we found that there is a significant start-up cost when beginning to track and monitor technical debt, but the cost of ongoing management soon declines to very reasonable levels. © 2014, Springer Science+Business Media New York.</p><br><a href="https://link.springer.com/article/10.1007/s10664-014-9351-7">link</a><br><h2>Título 74: The Perception of Technical Debt in the Embedded Systems Domain: An Industrial Case Study</h2><h3>Autores: ['A. Ampatzoglou', 'A. Ampatzoglou', 'A. Chatzigeorgiou', 'P. Avgeriou', 'P. Abrahamsson', 'A. Martini', 'U. Zdun', 'K. Systa']</h3><h4>Ano: 2016</h4><p>Technical Debt Management (TDM) has drawn the attention of software industries during the last years, including embedded systems. However, we currently lack an overview of how practitioners from this application domain perceive technical debt. To this end, we conducted a multiple case study in the embedded systems industry, to investigate: (a) the expected life-time of components that have TD, (b) the most frequently occurring types of TD in them, and (c) the significance of TD against run-time quality attributes. The case study was performed on seven embedded systems industries (telecommunications, printing, smart manufacturing, sensors, etc.) from five countries (Greece, Netherlands, Sweden, Austria, and Finland). The results of the case study suggest that: (a) maintainability is more seriously considered when the expected lifetime of components is larger than ten years, (b) the most frequent types of debt are test, architectural, and code debt, and (c) in embedded systems the run-time qualities are prioritized compared to design-time qualities that are usually associated with TD. The obtained results can be useful for both researchers and practitioners: the former can focus their research on the most industrially-relevant aspects of TD, whereas the latter can be informed about the most common types of TD and how to focus their TDM processes. © 2016 IEEE.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/7776447">link</a><br><h2>Título 73: Identification and management of technical debt: A systematic mapping study</h2><h3>Autores: ['Nicolli Alves', 'Thiago Mendes', 'Manoel Mendon{\\c{c}}a', "Rodrigo Sp{\\'\\i}nola", 'Forrest Shull', 'Carolyn Seaman']</h3><h4>Ano: 2016</h4><p>Context
The technical debt metaphor describes the effect of immature artifacts on software maintenance that bring a short-term benefit to the project in terms of increased productivity and lower cost, but that may have to be paid off with interest later. Much research has been performed to propose mechanisms to identify debt and decide the most appropriate moment to pay it off. It is important to investigate the current state of the art in order to provide both researchers and practitioners with information that enables further research activities as well as technical debt management in practice.
Objective
This paper has the following goals: to characterize the types of technical debt, identify indicators that can be used to find technical debt, identify management strategies, understand the maturity level of each proposal, and identify what visualization techniques have been proposed to support technical debt identification and management activities.
Method
A systematic mapping study was performed based on a set of three research questions. In total, 100 studies, dated from 2010 to 2014, were evaluated.
Results
We proposed an initial taxonomy of technical debt types, created a list of indicators that have been proposed to identify technical debt, identified the existing management strategies, and analyzed the current state of art on technical debt, identifying topics where new research efforts can be invested.
Conclusion
The results of this mapping study can help to identify points that still require further investigation in technical debt research.</p><br><a href="https://www.sciencedirect.com/science/article/pii/S0950584915001743">link</a><br><h2>Título 72: Cyclomatic complexity</h2><h3>Autores: ['Christof Ebert', 'James Cain', 'Giuliano Antoniol', 'Steve Counsell', 'Phillip Laplante']</h3><h4>Ano: 2016</h4><p>The cyclomatic complexity (CC) metric measures the number of linearly independent paths through a piece of code. Although Thomas McCabe developed CC for procedural languages, its popularity has endured throughout the object-oriented era. That said, CC is one of the most controversial metrics, shunned for the most part by academia for certain theoretical weaknesses and the belief that it's no more useful than a simple “lines of code” metric. However, most metrics collection tools support its collection, and, paradoxically, industry uses it extensively. So, why is this the case? This question also leads to fundamental perennial questions about industry's exposure to academic opinion and whether academic research fails to take account of software development's daily practicalities. Maybe industry is simply looking for straightforward, widely understood metrics?</p><br><a href="https://ieeexplore.ieee.org/abstract/document/7725232">link</a><br><h2>Título 71: A systematic mapping study on mining software repositories</h2><h3>Autores: ["M{\\'a}rio F. Farias", 'Renato Novais', "Methanias J{\\'u}nior", "Lu{\\'\\i}s Silva Carvalho", 'Manoel Mendon{\\c{c}}a', "Rodrigo Sp{\\'\\i}nola"]</h3><h4>Ano: 2016</h4><p>Background: Software repositories provide large amount of data encompassing software changes throughout its evolution. Those repositories can be effectively used to extract and analyze pertinent information and derive conclusions related to the software history or its current snapshot. Objective: This work aims to investigate recent studies on Mining Software Repositories (MSR) approaches collecting evidences about software analysis goals (purpose, focus, and object of analysis), data sources, evaluation methods, tools, and how the area is evolving. Method: A systematic mapping study was performed to identify and analyze research on mining software repositories by analyzing five editions of Working Conference on Mining Software Repositories -- the main conference on this area. Results: MSR approaches have been used for many different goals, mainly for comprehension of defects, analysis of the contribution and behavior of developers, and software evolution comprehension. Besides, some gaps were identified with respect to their goals, focus, and data source type (e.g. lack of usage of comments to identify smells, refactoring, and issues of software quality). Regarding the evaluation method, our analysis pointed out to an extensive usage of some types of empirical evaluation. Conclusion: Studies of the MSR have focused on different goals, however there are still many research opportunities to be explored and issues associated with MSR that should be considered.</p><br><a href="https://dl.acm.org/doi/abs/10.1145/2851613.2851786">link</a><br><h2>Título 70: Tool support for evaluating architectural debt of an existing system: An experience report</h2><h3>Autores: ['Francesca Fontana', 'Riccardo Roveda', 'Marco Zanoni']</h3><h4>Ano: 2016</h4><p>During software development, maintenance and evolution, we can assess the quality of code, design and architecture to capture hints of possible problems and face them as soon as possible. We can capture signals of architecture erosion in different ways by exploiting several tools with the aim to identify architectural violations, architectural smells or other relevant features. In this paper, we provide our experience report in using three known tools to capture information that can be useful to identify and evaluate the architectural debt of an application. We outline the main differences among these tools and the results they produce.</p><br><a href="https://dl.acm.org/doi/abs/10.1145/2851613.2851963">link</a><br><h2>Título 69: Identifying and quantifying architectural debt</h2><h3>Autores: ['Lu Xiao', 'Yuanfang Cai', 'Rick Kazman', 'Ran Mo', 'Qiong Feng']</h3><h4>Ano: 2016</h4><p>Our prior work showed that the majority of error-prone source files in a software system are architecturally connected. Flawed architectural relations propagate defectsamong these files and accumulate high maintenance costs over time, just like debts accumulate interest. We model groups of architecturally connected files that accumulate high maintenance costs as architectural debts. To quantify such debts, we formally define architectural debt, and show how to automatically identify debts, quantify their maintenance costs, and model these costs over time. We describe a novel history coupling probability matrix for this purpose, and identify architecture debts using 4 patterns of architectural flaws shown to correlate with reduced software quality. We evaluate our approach on 7 large-scale open source projects, and show that a significant portion of total project maintenance effort is consumed by paying interest on architectural debts. The top 5 architectural debts, covering a small portion (8% to 25%) of each project's error-prone files, capture a significant portion (20% to 61%) of each project's maintenance effort. Finally, we show that our approach reveals how architectural issues evolve into debts over time.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/7886928">link</a><br><h2>Título 67: Identification of architectural technical debt: An analysis based on naming patterns</h2><h3>Autores: ['Paul Carpio']</h3><h4>Ano: 2016</h4><p>Hasty software development can produce immediate implementations with source code unnecessarily complex and hardly readable. These small kinds of software decay generate a technical debt that could be big enough to seriously affect future maintenance activities. This work presents an analysis technique for identifying architectural technical debt related to non-uniformity of naming patterns; the technique is based on term frequency over package hierarchies. The proposal has been evaluated on projects of two popular organizations, Apache and Eclipse. The results have shown that most of the projects have frequent occurrences of the proposed naming patterns, and using a graph model and aggregated data could enable the elaboration of simple queries for debt identification. The technique has features that favor its applicability on emergent architectures and agile software development.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/7520104">link</a><br><h2>Título 99: Measure it? Manage it? Ignore it? software practitioners and technical debt</h2><h3>Autores: ['Neil Ernst', 'Stephany Bellomo', 'Ipek Ozkaya', 'Robert Nord', 'Ian Gorton']</h3><h4>Ano: 2015</h4><p>The technical debt metaphor is widely used to encapsulate numerous software quality problems. The metaphor is attractive to practitioners as it communicates to both technical and nontechnical audiences that if quality problems are not addressed, things may get worse. However, it is unclear whether there are practices that move this metaphor beyond a mere communication mechanism. Existing studies of technical debt have largely focused on code metrics and small surveys of developers. In this paper, we report on our survey of 1,831 participants, primarily software engineers and architects working in long-lived, software-intensive projects from three large organizations, and follow-up interviews of seven software engineers. We analyzed our data using both nonparametric statistics and qualitative text analysis. We found that architectural decisions are the most important source of technical debt. Furthermore, while respondents believe the metaphor is itself important for communication, existing tools are not currently helpful in managing the details. We use our results to motivate a technical debt timeline to focus management and tooling approaches.</p><br><a href="https://dl.acm.org/doi/abs/10.1145/2786805.2786848">link</a><br><h2>Título 98: Identifying and visualizing Architectural Debt and its efficiency interest in the automotive domain: A case study</h2><h3>Autores: ['Ulf Eliasson', 'Antonio Martini', 'Robert Kaufmann', 'Sam Odeh']</h3><h4>Ano: 2015</h4><p>Architectural Technical Debt has recently received the attention of the scientific community, as a suitable metaphor for describing sub-optimal architectural solutions having short- term benefits but causing a long-term negative impact. We study such phenomenon in the context of Volvo Car Group, where the development of modern cars includes complex systems with mechanical components, electronics and software working together in a complicated network to perform an increasing number of functions and meet the demands of many customers. This puts high requirements on having an architecture and design that can handle these demands. Therefore, it is of utmost importance to manage Architecture Technical Debt, in order to make sure that the advantages of sub-optimal solutions do not lead to the payment of a large interest. We conducted a case study at Volvo Car Group and we discovered that architectural violations in the detailed design had an impact on the efficiency of the communication between components, which is an essential quality in cars and other embedded systems. Such interest is not studied in literature, which usually focuses on the maintainability aspects of Technical Debt. To explore how this Architectural Technical Debt and its interest could be communicated to stakeholders, we developed a visual tool. We found that not only was the Architectural Debt highly interesting for the architects and other stakeholders at VCG, but the proposed visualization was useful in increasing the awareness of the impact that Architectural Technical Debt had on efficiency.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/7332622">link</a><br><h2>Título 97: The financial aspect of managing technical debt: A systematic literature review</h2><h3>Autores: ['Areti Ampatzoglou', 'Apostolos Ampatzoglou', 'Alexander Chatzigeorgiou', 'Paris Avgeriou']</h3><h4>Ano: 2015</h4><p>ContextTechnical debt is a software engineering metaphor, referring to the eventual financial consequences of trade-offs between shrinking product time to market and poorly specifying, or implementing a software product, throughout all development phases. Based on its inter-disciplinary nature, i.e. software engineering and economics, research on managing technical debt should be balanced between software engineering and economic theories.ObjectiveThe aim of this study is to analyze research efforts on technical debt, by focusing on their financial aspect. Specifically, the analysis is carried out with respect to: (a) how financial aspects are defined in the context of technical debt and (b) how they relate to the underlying software engineering concepts.MethodIn order to achieve the abovementioned goals, we employed a standard method for SLRs and applied it on studies retrieved from seven general-scope digital libraries. In total we selected 69 studies relevant to the financial aspect of technical debt.ResultsThe most common financial terms that are used in technical debt research are principal and interest, whereas the financial approaches that have been more frequently applied for managing technical debt are real options, portfolio management, cost/benefit analysis and value-based analysis. However, the application of such approaches lacks consistency, i.e., the same approach is differently applied in different studies, and in some cases lacks a clear mapping between financial and software engineering concepts.ConclusionThe results are expected to prove beneficial for the communication between technical managers and project managers, in the sense that they will provide a common vocabulary, and will help in setting up quality-related goals, during software development. To achieve this we introduce: (a) a glossary of terms and (b) a classification scheme for financial approaches used for managing technical debt. Based on these, we have been able to underline interesting implications for researchers and practitioners.</p><br><a href="https://www.sciencedirect.com/science/article/pii/S0950584915000762">link</a><br><h2>Título 96: Towards prioritizing architecture technical debt: information needs of architects and product owners</h2><h3>Autores: ['Antonio Martini', 'Jan Bosch']</h3><h4>Ano: 2015</h4><p>Architectural Technical Debt is a metaphor for representing sub-optimal architectural solutions that might cause an interest, in terms of effort or quality, to be paid by the organization in the long run. Such metaphor has been regarded as useful for communicating risks of suboptimal solutions between technical and non-technical stakeholders. However, it's fundamental to understand the information needs of the involved stakeholders in order to produce technical debt measurements that would allow proper communication and informed prioritization. We have investigated, through a combination of interviews, observations and a survey, what key information is needed by agile product owners and software architects in order to prioritize the refactoring of risky architectural technical debt items with respect to feature development.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/7302484">link</a><br><h2>Título 95: Architectural technical debt identification based on architecture decisions and change scenarios</h2><h3>Autores: ['Zengyang Li', 'Peng Liang', 'Paris Avgeriou']</h3><h4>Ano: 2015</h4><p>Architectural technical debt (ATD) is incurred by design decisions that intentionally or unintentionally compromise system-wide quality attributes, particularly maintainability and evolvability. ATD is harmful to the system's long-term health, thus it needs to be identified for further management. However, existing ATD identification approaches are mainly based on source code analysis and thus suffer from certain shortcomings: they can only identify issues at the system implementation, they can only be employed after the systems is implemented in code, they lack a mechanism to confirm whether the potential ATD identified is real ATD or not. To address these issues, we proposed an ATD identification approach based on architecture decisions and change scenarios. To evaluate the effectiveness and usability of this approach, we conducted a case study with an information system in a large telecommunications company. The results show that the proposed approach is useful and easy to use, and it supports release planning and ATD interest measurement.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/7158505">link</a><br><h2>Título 93: Research Methods: The Essential Knowledge Base</h2><h3>Autores: ['W. Trochim', 'J. Donnelly', 'K. Arora']</h3><h4>Ano: 2015</h4><p>?</p><br><a href="https://books.google.com.br/books?hl=en&lr=&id=0yxBBAAAQBAJ&oi=fnd&pg=PP1&dq=Research+Methods:+The+Essential+Knowledge+Base&ots=AFzQRcRIf-&sig=mAziIAxo34qWmGEzB5f1vWCfyS0&redir_esc=y#v=onepage&q=Research%20Methods%3A%20The%20Essential%20Knowledge%20Base&f=false">link</a><br><h2>Título 94: Applied regression analysis and generalized linear models</h2><h3>Autores: ['John Fox']</h3><h4>Ano: 2015</h4><p>?</p><br><a href="https://books.google.com.br/books?hl=en&lr=&id=3wrwCQAAQBAJ&oi=fnd&pg=PT15&dq=Applied+regression+analysis+and+generalized+linear+models&ots=3AasCdxgak&sig=GipCu6icU16wsROc7JplgFi3wYQ&redir_esc=y#v=onepage&q=Applied%20regression%20analysis%20and%20generalized%20linear%20models&f=false">link</a><br><h2>Título 90: Global software engineering: An industry perspective</h2><h3>Autores: ['Christof Ebert', 'Marco Kuhrmann', 'Rafael Prikladnicki']</h3><h4>Ano: 2015</h4><p>Professional software products and IT systems and services today are developed mostly by globally distributed teams, projects, and companies. This issue's column summarizes experiences and guidance from industry to facilitate knowledge and technology transfer. It's based on industry feedback from the annual IEEE International Conference on Global Software Engineering.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/7367984">link</a><br><h2>Título 92: Extending survivability models for global software development with media synchronicity theory</h2><h3>Autores: ['Alberto Avritzer', 'Sarah Beecham', 'Ricardo Britto', 'Josiane Kroll', 'Daniel Menasche', 'John Noll', 'Maria Paasivaara']</h3><h4>Ano: 2015</h4><p>In this paper we propose a new framework to assess survivability of software projects accounting for media capability details as introduced in Media Synchronicity Theory (MST). Specifically, we add to our global engineering framework the assessment of the impact of inadequate conveyance and convergence available in the communication infrastructure selected to be used by the project, on the system ability to recover from project disasters. We propose an analytical model to assess how the project recovers from project disasters related to process and communication failures. Our model is based on media synchronicity theory to account for how information exchange impacts recovery. Then, using the proposed model we evaluate how different interventions impact communication effectiveness. Finally, we parameterize and instantiate the proposed survivability model based on a data gathering campaign comprising thirty surveys collected from senior global software development experts at ICGSE'2014 and GSD'2015.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/7224477">link</a><br><h2>Título 89: The danger of architectural technical debt: Contagious debt and vicious circles</h2><h3>Autores: ['Antonio Martini', 'Jan Bosch']</h3><h4>Ano: 2015</h4><p>A known problem in large software companies is to balance the prioritization of short-term with long-term viability. Specifically, architecture violations (Architecture Technical Debt) taken to deliver fast might hinder future feature development. However, some technical debt requires more interest to be paid than other. We have investigated which Technical Debt items generate more effort and how this effort is manifested during software development. We conducted a multiple-case embedded case study comprehending 7 sites at 5 large international software companies. We found that some Technical Debt items are contagious, causing other parts of the system to be contaminated with the same problem, which may lead to non-linear growth of interest. We also identify another socio-technical phenomenon, for which a combination of weak awareness of debt, time pressure and refactoring creates Vicious Circles of events during the development. Such phenomena need to be identified and stopped before the development is led to a crisis point. Finally, this paper presents a taxonomy of the most dangerous items identified during the qualitative investigation and a model of their effects that can be used for prioritization, for further investigation and as a quality model for extracting more precise and context-specific metrics.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/7158498">link</a><br><h2>Título 88: A systematic mapping study on technical debt and its management</h2><h3>Autores: ['Zengyang Li', 'Paris Avgeriou', 'Peng Liang']</h3><h4>Ano: 2015</h4><p>Context
Technical debt (TD) is a metaphor reflecting technical compromises that can yield short-term benefit but may hurt the long-term health of a software system.
Objective
This work aims at collecting studies on TD and TD management (TDM), and making a classification and thematic analysis on these studies, to obtain a comprehensive understanding on the TD concept and an overview on the current state of research on TDM.
Method
A systematic mapping study was performed to identify and analyze research on TD and its management, covering publications between 1992 and 2013.
Results
Ninety-four studies were finally selected. TD was classified into 10 types, 8 TDM activities were identified, and 29 tools for TDM were collected.
Conclusions
The term “debt” has been used in different ways by different people, which leads to ambiguous interpretation of the term. Code-related TD and its management have gained the most attention. There is a need for more empirical studies with high-quality evidence on the whole TDM process and on the application of specific TDM approaches in industrial settings. Moreover, dedicated TDM tools are needed for managing various types of TD in the whole TDM process.</p><br><a href="https://www.sciencedirect.com/science/article/pii/S0164121214002854">link</a><br><h2>Título 87: Applicability of technical debt as a concept to understand obstacles for evolution of automated production systems</h2><h3>Autores: ['Birgit Vogel-Heuser', 'Susanne R{\\"o}sch']</h3><h4>Ano: 2015</h4><p>Automated production systems (aPS), a specific class of mechatronic systems, are complex, long living, software intensive, evolving systems designed according to customer request. Often, the evolution of such systems has to cope with imponderables and sudden disturbances of the systematic development or maintenance process. In software engineering, the concept of technical debt and, in more detail, architectural technical debt has been introduced recently to describe phenomena, which increase software development costs over time. This paper tries to adapt and apply the classification of technical debt and architectural technical debt to automated production systems, identifying similar dimensions but adding specific challenges, causes and their effects. Once the causes and effects are identified, management and recovery strategies coping with technical debt and architectural technical debt shall be developed in the future, thereby enlarging the strategies from software engineering. The adapted classification and adaptations are based on the experience of several industrial projects in aPS.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/7379167">link</a><br><h2>Título 86: Investigating architectural technical debt accumulation and refactoring over time: A multiple-case study</h2><h3>Autores: ['Antonio Martini', 'Jan Bosch', 'Michel Chaudron']</h3><h4>Ano: 2015</h4><p>Context
A known problem in large software companies is to balance the prioritization of short-term with long-term feature delivery speed. Specifically, Architecture Technical Debt is regarded as sub-optimal architectural solutions taken to deliver fast that might hinder future feature development, which, in turn, would hinder agility.
Objective
This paper aims at improving software management by shedding light on the current factors responsible for the accumulation of Architectural Technical Debt and to understand how it evolves over time.
Method
We conducted an exploratory multiple-case embedded case study in 7 sites at 5 large companies. We evaluated the results with additional cross-company interviews and an in-depth, company-specific case study in which we initially evaluate factors and models.
Results
We compiled a taxonomy of the factors and their influence in the accumulation of Architectural Technical Debt, and we provide two qualitative models of how the debt is accumulated and refactored over time in the studied companies. We also list a set of exploratory propositions on possible refactoring strategies that can be useful as insights for practitioners and as hypotheses for further research.
Conclusion
Several factors cause constant and unavoidable accumulation of Architecture Technical Debt, which leads to development crises. Refactorings are often overlooked in prioritization and they are often triggered by development crises, in a reactive fashion. Some of the factors are manageable, while others are external to the companies. ATD needs to be made visible, in order to postpone the crises according to the strategic goals of the companies. There is a need for practices and automated tools to proactively manage ATD.</p><br><a href="https://www.sciencedirect.com/science/article/pii/S0950584915001287">link</a><br><h2>Título 85: Addressing efficiency interest in architectural technical debt-A measurement and visualization approach for embedded software</h2><h3>Autores: ['Robert Kaufmann', 'Sam Odeh']</h3><h4>Ano: 2015</h4><p>Addressing and managing technical debt is an important part of software development. Unmanaged technical debt, especially architectural technical debt, can lead to additional development overhead and expensive refactoring. However, most research that address architectural technical debt does so by analyzing source code; very little research focus on a more abstract level. The problem with analyzing source code to identify debt is that it is not enough to cover all debt. Similarly, most visualisation of software architecture target lower level artifacts based on static code analysis. Therefore there is a gap in both addressing architectural technical debt and software visualisation on a more abstract level. By utilizing a case study at a company, followed by design research, we contribute to filling this gap by identifying, measuring, and visualizing architectural debt on a higher abstraction level. Specifically, we identify occurring debt items related to efficiency interest and propose methodologies to measure and visualize them utilizing architectural models. Thus, we provide novel techniques of</p><br><a href="https://odr.chalmers.se/handle/20.500.12380/219830">link</a><br><h2>Título 91: A Case Study in Locating the Architectural Roots of Technical Debt</h2><h3>Autores: ['Rick Kazman', 'Yuanfang Cai', 'Ran Mo', 'Qiong Feng', 'Lu Xiao', 'Serge Haziyev', 'Volodymyr Fedak', 'Andriy Shapochka']</h3><h4>Ano: 2015</h4><p>Our recent research has shown that, in large-scale software systems, defective files seldom exist alone. They are usually architecturally connected, and their architectural structures exhibit significant design flaws which propagate bugginess among files. We call these flawed structures the architecture roots, a type of technical debt that incurs high maintenance penalties. Removing the architecture roots of bugginess requires refactoring, but the benefits of refactoring have historically been difficult for architects to quantify or justify. In this paper, we present a case study of identifying and quantifying such architecture debts in a large-scale industrial software project. Our approach is to model and analyze software architecture as a set of design rule spaces (DRSpaces). Using data extracted from the project's development artifacts, we were able to identify the files implicated in architecture flaws and suggest refactorings based on removing these flaws. Then we built economic models of the before and (predicted) after states, which gave the organization confidence that doing the refactorings made business sense, in terms of a handsome return on investment.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/7202962">link</a><br><h2>Título 107: A systematic review of software architecture visualization techniques</h2><h3>Autores: ['Mojtaba Shahin', 'Peng Liang', 'Muhammad Babar']</h3><h4>Ano: 2014</h4><p>Context
Given the increased interest in using visualization techniques (VTs) to help communicate and understand software architecture (SA) of large scale complex systems, several VTs and tools have been reported to represent architectural elements (such as architecture design, architectural patterns, and architectural design decisions). However, there is no attempt to systematically review and classify the VTs and associated tools reported for SA, and how they have been assessed and applied.
Objective
This work aimed at systematically reviewing the literature on software architecture visualization to develop a classification of VTs in SA, analyze the level of reported evidence and the use of different VTs for representing SA in different application domains, and identify the gaps for future research in the area.
Method
We used systematic literature review (SLR) method of the evidence-based software engineering (EBSE) for reviewing the literature on VTs for SA. We used both manual and automatic search strategies for searching the relevant papers published between 1 February 1999 and 1 July 2011.
Results
We selected 53 papers from the initially retrieved 23,056 articles for data extraction, analysis, and synthesis based on pre-defined inclusion and exclusion criteria. The results from the data analysis enabled us to classify the identified VTs into four types based on the usage popularity: graph-based, notation-based, matrix-based, and metaphor-based VTs. The VTs in SA are mostly used for architecture recovery and architectural evolution activities. We have also identified ten purposes of using VTs in SA. Our results also revealed that VTs in SA have been applied to a wide range of application domains, among which “graphics software” and “distributed system” have received the most attention.
Conclusion
SA visualization has gained significant importance in understanding and evolving software-intensive systems. However, only a few VTs have been employed in industrial practice. This review has enabled us to identify the following areas for further research and improvement: (i) it is necessary to perform more research on applying visualization techniques in architectural analysis, architectural synthesis, architectural implementation, and architecture reuse activities; (ii) it is essential to pay more attention to use more objective evaluation methods (e.g., controlled experiment) for providing more convincing evidence to support the promised benefits of using VTs in SA; (iii) it is important to conduct industrial surveys for investigating how software architecture practitioners actually employ VTs in architecting process and what are the issues that hinder and prevent them from adopting VTs in SA.</p><br><a href="https://www.sciencedirect.com/science/article/pii/S0164121214000831">link</a><br><h2>Título 112: Architectural debt management in value-oriented architecting</h2><h3>Autores: ['Zengyang Li', 'Peng Liang', 'Paris Avgeriou']</h3><h4>Ano: 2014</h4><p>Architectural technical debt (ATD) may be incurred when making architecture decisions. In most cases, ATD is not effectively managed in the architecting process: It is not made explicit, and architecture decision making does not consider the ATD incurred by the different design options. This chapter proposes a conceptual model of ATD and an architectural technical debt management process applying this ATD conceptual model in order to facilitate decision making in a value-oriented perspective of architecting. We also demonstrate how ATD management can be employed in architectural synthesis and evaluation in a case study. The contribution of this work provides a controllable and predictable balance between the value and cost of architecture design in the long term.</p><br><a href="https://www.sciencedirect.com/science/article/pii/B978012410464800009X">link</a><br><h2>Título 111: An empirical investigation of modularity metrics for indicating architectural technical debt</h2><h3>Autores: ['Zengyang Li', 'Peng Liang', 'Paris Avgeriou', 'Nicolas Guelfi', 'Apostolos Ampatzoglou']</h3><h4>Ano: 2014</h4><p>Architectural technical debt (ATD) is incurred by design decisions that consciously or unconsciously compromise system-wide quality attributes, particularly maintainability and evolvability. ATD needs to be identified and measured, so that it can be monitored and eventually repaid, when appropriate. In practice, ATD is difficult to identify and measure, since ATD does not yield observable behaviors to end users. One indicator of ATD, is the average number of modified components per commit (ANMCC): a higher ANMCC indicates more ATD in a software system. However, it is difficult and sometimes impossible to calculate ANMCC, because the data (i.e., the log of commits) are not always available. In this work, we propose to use software modularity metrics, which can be directly calculated based on source code, as a substitute of ANMCC to indicate ATD. We validate the correlation between ANMCC and modularity metrics through a holistic multiple case study on thirteen open source software projects. The results of this study suggest that two modularity metrics, namely Index of Package Changing Impact (IPCI) and Index of Package Goal Focus (IPGF), have significant correlation with ANMCC, and therefore can be used as alternative ATD indicators.</p><br><a href="https://dl.acm.org/doi/abs/10.1145/2602576.2602581">link</a><br><h2>Título 110: Qualitative content analysis: theoretical foundation, basic procedures and software solution</h2><h3>Autores: ['Philipp Mayring']</h3><h4>Ano: 2014</h4><p>?</p><br><a href="https://www.ssoar.info/ssoar/bitstream/handle/document/39517/ssoar-2014-mayring-Qualitative_content_analysis_theoretical_foundation.pdf">link</a><br><h2>Título 109: Evaluating Technical Debt in Cloud-Based Architectures Using Real Options</h2><h3>Autores: ['E. Alzaghoul', 'R. Bahsoon']</h3><h4>Ano: 2014</h4><p>A Cloud-based Service-Oriented Architecture (CBSOA) is typically composed of web services, which are offered off the cloud marketplace. CB-SOA can improve its utility and add value to its composition by switching among its constituent services. We look at the option to defer the decision of substitution under uncertainty. We exploit Binomial Options to the formulation. We quantify the time-value of the architecture decisions of switching web services and technical debt they can imply on the structure. As CB-SOA are market-sensitive, dynamic and "volatile", the decision of deferral tends to be sensitive to these dynamics. Henceforth, the structural complexity of a CB-SOAcan change over time and so the technical debt as its constituent web services are modified, replaced, upgraded, etc. The method builds on Design Structure Matrix (DSM) and introduces time and complexity aware propagation cost metrics to assess the value of deferral decisions relative to changes in the structure. Architects of CB-SOA can use our method to assess the time value of deferring the decisions to switch web services relative to complexity, technical debt and value creation. We demonstrate the applicability of the method using an illustrative example.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/6824100">link</a><br><h2>Título 108: Technical debt and the effect of agile software development practices on it-an industry practitioner survey</h2><h3>Autores: ['Johannes Holvitie', 'Ville Leppanen', 'Sami Hyrynsalmi']</h3><h4>Ano: 2014</h4><p>A major reason for the popularity of agile and lean software methods is their capability to function in resource scarce and requirement erratic environments. Both of these characteristics cause accumulation of technical debt, something that is the end result of either intentional or unintentional decisions. The ability of these methods to function with technical debt indicates that they contain components with inherent technical debt management capabilities. This study conducts a survey on industry practitioners to discover what is their level of technical debt knowledge, how does technical debt manifest in their projects and which of the applied components of agile software development -- both processes and practices -- are sensitive to technical debt. This paper contributes to the technical debt discussion by showing differences in assumed and indicated technical debt knowledge. Furthermore, components closest to implementation and its maintenance are perceived to have the most positive effects on technical debt management. Finally, the most encountered instances of technical debt are caused by architectural inadequacies, they are internal legacy, and increase in size as a result of continued implementation.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/6974888">link</a><br><h2>Título 105: Towards building a universal defect prediction model</h2><h3>Autores: ['Feng Zhang', 'Audris Mockus', 'Iman Keivanloo', 'Ying Zou']</h3><h4>Ano: 2014</h4><p>To predict files with defects, a suitable prediction model must be built for a software project from either itself (within-project) or other projects (cross-project). A universal defect prediction model that is built from the entire set of diverse projects would relieve the need for building models for an individual project. A universal model could also be interpreted as a basic relationship between software metrics and defects. However, the variations in the distribution of predictors pose a formidable obstacle to build a universal model. Such variations exist among projects with different context factors (e.g., size and programming language). To overcome this challenge, we propose context-aware rank transformations for predictors. We cluster projects based on the similarity of the distribution of 26 predictors, and derive the rank transformations using quantiles of predictors for a cluster. We then fit the universal model on the transformed data of 1,398 open source projects hosted on SourceForge and GoogleCode. Adding context factors to the universal model improves the predictive power. The universal model obtains prediction performance comparable to the within-project models and yields similar results when applied on five external projects (one Apache and four Eclipse projects). These results suggest that a universal defect prediction model may be an achievable goal.</p><br><a href="https://dl.acm.org/doi/abs/10.1145/2597073.2597078">link</a><br><h2>Título 106: Incremental origin analysis of source code files</h2><h3>Autores: ['Daniela Steidl', 'Benjamin Hummel', 'Elmar Juergens']</h3><h4>Ano: 2014</h4><p>The history of software systems tracked by version control systems is often incomplete because many file movements are not recorded. However, static code analyses that mine the file history, such as change frequency or code churn, produce precise results only if the complete history of a source code file is available. In this paper, we show that up to 38.9% of the files in open source systems have an incomplete history, and we propose an incremental, commit-based approach to reconstruct the history based on clone information and name similarity. With this approach, the history of a file can be reconstructed across repository boundaries and thus provides accurate information for any source code analysis. We evaluate the approach in terms of correctness, completeness, performance, and relevance with a case study among seven open source systems and a developer survey.</p><br><a href="https://dl.acm.org/doi/abs/10.1145/2597073.2597111">link</a><br><h2>Título 104: Titan: A toolset that connects software architecture with quality analysis</h2><h3>Autores: ['Lu Xiao', 'Yuanfang Cai', 'Rick Kazman']</h3><h4>Ano: 2014</h4><p>In this tool demo, we will illustrate our tool---Titan---that supports a new architecture model: design rule spaces (DRSpaces). We will show how Titan can capture both architecture and evolutionary structure and help to bridge the gap between architecture and defect prediction. We will demo how to use our toolset to capture hundreds of buggy files into just a few architecturally related groups, and to reveal architecture issues that contribute to the error-proneness and change-proneness of these groups. Our tool has been used to analyze dozens of large-scale industrial projects, and has demonstrated its ability to provide valuable direction on which parts of the architecture are problematic, and on why, when, and how to refactor. The video demo of Titan can be found at https://art.cs.drexel.edu/~lx52/titan.mp4</p><br><a href="https://dl.acm.org/doi/abs/10.1145/2635868.2661677">link</a><br><h2>Título 103: An exploratory study on self-admitted technical debt</h2><h3>Autores: ['Aniket Potdar', 'Emad Shihab']</h3><h4>Ano: 2014</h4><p>Throughout a software development life cycle, developers knowingly commit code that is either incomplete, requires rework, produces errors, or is a temporary workaround. Such incomplete or temporary workarounds are commonly referred to as 'technical debt'. Our experience indicates that self-admitted technical debt is common in software projects and may negatively impact software maintenance, however, to date very little is known about them. Therefore, in this paper, we use source-code comments in four large open source software projects-Eclipse, Chromium OS, Apache HTTP Server, and ArgoUML to identify self-admitted technical debt. Using the identified technical debt, we study 1) the amount of self-admitted technical debt found in these projects, 2) why this self-admitted technical debt was introduced into the software projects and 3) how likely is the self-admitted technical debt to be removed after their introduction. We find that the amount of self-admitted technical debt exists in 2.4%-31% of the files. Furthermore, we find that developers with higher experience tend to introduce most of the self-admitted technical debt and that time pressures and complexity of the code do not correlate with the amount of self-admitted technical debt. Lastly, although self-admitted technical debt is meant to be addressed or removed in the future, only between 26.3%-63.5% of self-admitted technical debt gets removed from projects after introduction.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/6976075">link</a><br><h2>Título 102: Identifying risky areas of software code in Agile/Lean software development: An industrial experience report</h2><h3>Autores: ['Vard Antinyan', 'Miroslaw Staron', 'Wilhelm Meding', 'Per {\\"O}sterstr{\\"o}m', 'Erik Wikstrom', 'Johan Wranker', 'Anders Henriksson', 'J{\\"o}rgen Hansson']</h3><h4>Ano: 2014</h4><p>Modern software development relies on incremental delivery to facilitate quick response to customers' requests. In this dynamic environment the continuous modifications of software code can cause risks for software developers; when developing a new feature increment, the added or modified code may contain fault-prone or difficult-to-maintain elements. The outcome of these risks can be defective software or decreased development velocity. This study presents a method to identify the risky areas and assess the risk when developing software code in Lean/Agile environment. We have conducted an action research project in two large companies, Ericsson AB and Volvo Group Truck Technology. During the study we have measured a set of code properties and investigated their influence on risk. The results show that the superposition of two metrics, complexity and revisions of a source code file, can effectively enable identification and assessment of the risk. We also illustrate how this kind of assessment can be successfully used by software developers to manage risks on a weekly basis as well as release-wise. A measurement system for systematic risk assessment has been introduced to two companies.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/6747165">link</a><br><h2>Título 101: Refactoring for software design smells: managing technical debt</h2><h3>Autores: ['Girish Suryanarayana', 'Ganesh Samarthyam', 'Tushar Sharma']</h3><h4>Ano: 2014</h4><p>?</p><br><a href="https://books.google.com.br/books?hl=en&lr=&id=1SaOAwAAQBAJ&oi=fnd&pg=PP1&dq=Refactoring+for+software+design+smells:+managing+technical+debt&ots=Oxf1DF3yIc&sig=FMPq9k5BYWA5xatE3LWqRkwom0I&redir_esc=y#v=onepage&q=Refactoring%20for%20software%20design%20smells%3A%20managing%20technical%20debt&f=false">link</a><br><h2>Título 100: Architecture technical debt: Understanding causes and a qualitative model</h2><h3>Autores: ['Antonio Martini', 'Jan Bosch', 'Michel Chaudron']</h3><h4>Ano: 2014</h4><p>A known problem in large software companies is to balance the prioritization of short-term with long-term responsiveness. Specifically, architecture violations (Architecture Technical Debt) taken to deliver fast might hinder future feature development, which would hinder agility. We conducted a multiple-case embedded case study in 7 sites at 5 large companies in order to shed light on the current causes for the accumulation of Architectural Technical Debt that causes effort. We provide a taxonomy of the factors and their influence in the accumulation of debt, and we provide a qualitative model of how the debt is accumulated and recovered over time.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/6928795">link</a><br><h2>Título 118: Handbook of univariate and multivariate data analysis with IBM SPSS</h2><h3>Autores: ['Robert Ho']</h3><h4>Ano: 2013</h4><p>?</p><br><a href="https://books.google.com.br/books?hl=en&lr=&id=DXtFAQAAQBAJ&oi=fnd&pg=PP1&dq=Handbook+of+univariate+and+multivariate+data+analysis+with+IBM+SPSS&ots=5q0nWXJ5NT&sig=3GhnixfTwUC2ysE_1O8NBXTipbE&redir_esc=y#v=onepage&q=Handbook%20of%20univariate%20and%20multivariate%20data%20analysis%20with%20IBM%20SPSS&f=false">link</a><br><h2>Título 121: A suite of metrics for quantifying historical changes to predict future change-prone classes in object-oriented software</h2><h3>Autores: ['Mahmoud Elish', 'Mojeeb Al-Rahman Al-Khiaty']</h3><h4>Ano: 2013</h4><p>Software systems are subject to series of changes during their evolution as they move from one release to the next. The change histories of software systems hold useful information that describes how artifacts evolved. Evolution-based metrics, which are the means to quantify the change history, are potentially good indicators of the changes in a software system. The objective of this paper is to derive and validate (theoretically and empirically) a set of evolution-based metrics as potential indicators of the change-prone classes of an object-oriented system when moving from one release to the next. Release-by-release statistical prediction models were built in different ways. The results indicate that the proposed evolution-based metrics measure different dimensions from those of typical product metrics. Additionally, several evolution-based metrics were found to be correlated with the change-proneness of classes. Moreover, the results indicate that more accurate prediction of class change-proneness is achieved when the evolution-based metrics are combined with product metrics.</p><br><a href="https://onlinelibrary.wiley.com/doi/full/10.1002/smr.1549">link</a><br><h2>Título 120: Driving quality improvement and reducing technical debt with the definition of done</h2><h3>Autores: ['Noopur Davis']</h3><h4>Ano: 2013</h4><p>This paper describes our experiences in using the Scrum concept of Definition of Done to drive quality improvements and reduce technical debt. We also describe how the Definition of Done can be a vehicle to implement standards, use checklists, and introduce compliance measures in the Agile development process.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/6612893">link</a><br><h2>Título 119: What is social debt in software engineering?</h2><h3>Autores: ['Damian Tamburri', 'Philippe Kruchten', 'Patricia Lago', 'Hans Vliet']</h3><h4>Ano: 2013</h4><p>“Social debt” in software engineering informally refers to unforeseen project cost connected to a “suboptimal” development community. The causes of suboptimal development communities can be many, ranging from global distance to organisational barriers to wrong or uninformed socio-technical decisions (i.e., decisions that influence both social and technical aspects of software development). Much like technical debt, social debt impacts heavily on software development success. We argue that, to ensure quality software engineering, practitioners should be provided with mechanisms to detect and manage the social debt connected to their development communities. This paper defines and elaborates on social debt, pointing out relevant research paths. We illustrate social debt by comparison with technical debt and discuss common real-life scenarios that exhibit “sub-optimal” development communities.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/6614739">link</a><br><h2>Título 116: Managing Technical Debt: An Industrial Case Study</h2><h3>Autores: ['Zadia Codabux', 'Byron Williams']</h3><h4>Ano: 2013</h4><p>Technical debt is the consequence of trade-offs made during software development to ensure speedy releases. The research community lacks rigorously evaluated guidelines to help practitioners characterize, manage and prioritize debt. This paper describes a study conducted with an industrial partner during their implementation of Agile development practices for a large software development division within the company. The report contains our initial findings based on ethnographic observations and semi-structured interviews. The goal is to identify the best practices regarding managing technical debt so that the researchers and the practitioners can further evaluate these practices to extend their knowledge of the technical debt metaphor. We determined that the developers considered their own taxonomy of technical debt based on the type of work they were assigned and their personal understanding of the term. Despite management's high-level categories, the developers mostly considered design debt, testing debt and defect debt. In addition to developers having their own taxonomy, assigning dedicated teams for technical debt reduction and allowing other teams about 20% of time per sprint for debt reduction are good initiatives towards lowering technical debt. While technical debt has become a well-regarded concept in the Agile community, further empirical evaluation is needed to assess how to properly apply the concept for various development organizations.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/6608672">link</a><br><h2>Título 117: SonarQube in action</h2><h3>Autores: ['G Campbell', 'Patroklos Papapetrou']</h3><h4>Ano: 2013</h4><p>SonarQube platform is an open source initiative with the goal of assessing the quality of the software projects. Currently, contributors have focused on providing source code analysis functions essentially for Java-based projects. However, in certain domains Java is not the predominant language such as critical software projects in transport, avionics, or medical systems. This paper presents how to provide plugins to enhance the current capabilities of the platform in order to include coding rules analysis results from external tools; the platform is then enriched with the results of external tools.</p><br><a href="https://link.springer.com/chapter/10.1007/978-3-319-40162-1_50">link</a><br><h2>Título 115: The msr cookbook: Mining a decade of research</h2><h3>Autores: ['Hadi Hemmati', 'Sarah Nadi', 'Olga Baysal', 'Oleksii Kononenko', 'Wei Wang', 'Reid Holmes', 'Michael Godfrey']</h3><h4>Ano: 2013</h4><p>The Mining Software Repositories (MSR) research community has grown significantly since the first MSR workshop was held in 2004. As the community continues to broaden its scope and deepens its expertise, it is worthwhile to reflect on the best practices that our community has developed over the past decade of research. We identify these best practices by surveying past MSR conferences and workshops. To that end, we review all 117 full papers published in the MSR proceedings between 2004 and 2012. We extract 268 comments from these papers, and categorize them using a grounded theory methodology. From this evaluation, four high-level themes were identified: data acquisition and preparation, synthesis, analysis, and sharing/replication. Within each theme we identify several common recommendations, and also examine how these recommendations have evolved over the past decade. In an effort to make this survey a living artifact, we also provide a public forum that contains the extracted recommendations in the hopes that the MSR community can engage in a continuing discussion on our evolving best practices.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/6624048">link</a><br><h2>Título 114: An exploration of technical debt</h2><h3>Autores: ['Edith Tom', 'Ayb{\\"u}Ke Aurum', 'Richard Vidgen']</h3><h4>Ano: 2013</h4><p>Context
Whilst technical debt is considered to be detrimental to the long term success of software development, it appears to be poorly understood in academic literature. The absence of a clear definition and model for technical debt exacerbates the challenge of its identification and adequate management, thus preventing the realisation of technical debt's utility as a conceptual and technical communication device.
Objective
To make a critical examination of technical debt and consolidate understanding of the nature of technical debt and its implications for software development.
Method
An exploratory case study technique that involves multivocal literature review, supplemented by interviews with software practitioners and academics to establish the boundaries of the technical debt phenomenon.
Result
A key outcome of this research is the creation of a theoretical framework that provides a holistic view of technical debt comprising a set of technical debts dimensions, attributes, precedents and outcomes, as well as the phenomenon itself and a taxonomy that describes and encompasses different forms of the technical debt phenomenon.
Conclusion
The proposed framework provides a useful approach to understanding the overall phenomenon of technical debt for practical purposes. Future research should incorporate empirical studies to validate heuristics and techniques that will assist practitioners in their management of technical debt.</p><br><a href="https://www.sciencedirect.com/science/article/pii/S0164121213000022">link</a><br><h2>Título 113: Statistical methods for rates and proportions</h2><h3>Autores: ['Joseph Fleiss', 'Bruce Levin', 'Myunghee Paik']</h3><h4>Ano: 2013</h4><p>?</p><br><a href="https://books.google.com.br/books?hl=en&lr=&id=9VefO7a8GeAC&oi=fnd&pg=PT13&dq=Statistical+methods+for+rates+and+proportions&ots=pr4iKGtyDV&sig=A7p3ZRHLBq99r4A-3lq3NwLZY50&redir_esc=y#v=onepage&q=Statistical%20methods%20for%20rates%20and%20proportions&f=false">link</a><br><h2>Título 126: Estimating the principal of an application's technical debt</h2><h3>Autores: ['Bill Curtis', 'Jay Sappidi', 'Alexandra Szynkarski']</h3><h4>Ano: 2012</h4><p>This article characterizes technical debt across 700 business applications, comprising 357 MLOC. These applications were analyzed against more than 1,200 rules of good architectural and coding practice. The authors present a formula with adjustable parameters for estimating the principal of technical debt from structural quality data.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/6336724">link</a><br><h2>Título 130: Technical debt: From metaphor to theory and practice</h2><h3>Autores: ['Philippe Kruchten', 'Robert Nord', 'Ipek Ozkaya']</h3><h4>Ano: 2012</h4><p>The metaphor of technical debt in software development was introduced two decades ago to explain to nontechnical stakeholders the need for what we call now "refactoring." As the term is being used to describe a wide range of phenomena, this paper proposes an organization of the technical debt landscape, and introduces the papers on technical debt contained in the issue.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/6336722">link</a><br><h2>Título 129: A balancing act: what software practitioners have to say about technical debt</h2><h3>Autores: ['Erin Lim', 'Nitin Taksande', 'Carolyn Seaman']</h3><h4>Ano: 2012</h4><p>An interview study involving 35 practitioners from a variety of domains aimed to characterize technical debt at the ground level to find out how software practitioners perceive it. The study also aimed to understand the context in which technical debt occurs, including its causes, symptoms, and effects. In addition, the study focused on how practitioners currently deal with technical debt. This analysis paints a picture of a large, complex balancing act of various short- and long-term concerns. The Web Extra gives the interview questions used by Erin Lim, Nitin Taksande, and Carolyn Seaman.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/6280547">link</a><br><h2>Título 127: Global Software and IT</h2><h3>Autores: ['Christof Ebert']</h3><h4>Ano: 2012</h4><p>The last several decades have witnessed a steady, irreversible trend toward the globalization of business, and of software-intensive high-technology businesses in particular. Economic forces are relentlessly turning national markets into global markets and spawning new forms of competition and cooperation that reach across national boundaries. This change is having a profound impact not only on marketing and distribution but also on the way produces are conceived, designed, constructed, tested, and delivered to customers. The author considers how software development is increasingly a multisite, multicultural, globally distributed undertaking</p><br><a href="https://ieeexplore.ieee.org/abstract/document/914732">link</a><br><h2>Título 128: Case Study Research in Software Engineering: Guidelines and Examples</h2><h3>Autores: ['P. Runeson', 'M. Host', 'A. Rainer', 'B. Regnell']</h3><h4>Ano: 2012</h4><p>?</p><br><a href="https://books.google.com.br/books?hl=en&lr=&id=T7rXoaxqPIAC&oi=fnd&pg=PT8&dq=Case+Study+Research+in+Software+Engineering:+Guidelines+and+Examples&ots=bcBrvcEazM&sig=0YJQ2wxNXjbZFKR6sc-hS9Z0zZM&redir_esc=y#v=onepage&q=Case%20Study%20Research%20in%20Software%20Engineering%3A%20Guidelines%20and%20Examples&f=false">link</a><br><h2>Título 125: An empirical investigation of changes in some software properties over time</h2><h3>Autores: ['Joseph Gil', 'Maayan Goldstein', 'Dany Moshkovich']</h3><h4>Ano: 2012</h4><p>Software metrics are easy to define, but not so easy to justify. It is hard to prove that a metric is valid, i.e., that measured numerical values imply anything on the vaguely defined, yet crucial software properties such as complexity and maintainability. This paper employs statistical analysis and tests to check some plausible assumptions on the behavior of software and metrics measured for this software in retrospective on its versions evolution history. Among those are the reliability assumption implicit in the application of any code metric, and the assumption that the magnitude of change, i.e., increase or decrease of its size, in a software artifact is correlated with changes to its version number. Putting a suite of 36 metrics to the trial, we confirm most of the assumptions on a large repository of software artifacts. Surprisingly, we show that a substantial portion of the reliability of some metrics can be observed even in random changes to architecture. Another surprising result is that Boolean-valued metrics tend to flip their values more often in minor software version increments than in major increments.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/6224285">link</a><br><h2>Título 124: In search of a metric for managing architectural technical debt</h2><h3>Autores: ['Robert Nord', 'Ipek Ozkaya', 'Philippe Kruchten', 'Marco Gonzalez-Rojas']</h3><h4>Ano: 2012</h4><p>Practices designed to expedite the delivery of stakeholder value can paradoxically lead to unexpected rework costs that ultimately degrade the flow of value over time. This is especially observable when features are developed based on immediate value, while dependencies that may slow down future development efforts are neglected. The technical debt metaphor conceptualizes this tradeoff between short-term and long-term value: taking shortcuts to optimize the delivery of features in the short term incurs debt, analogous to financial debt, that must be paid off later to optimize long-term success. In this paper, we describe taking an architecture-focused and measurement-based approach to develop a metric that assists in strategically managing technical debt. Such an approach can be used to optimize the cost of development over time while continuing to deliver value to the customer. We demonstrate our approach by describing its application to an ongoing system development effort.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/6337765">link</a><br><h2>Título 123: Experimentation in software engineering</h2><h3>Autores: ['Claes Wohlin', 'Per Runeson', 'Martin H{\\"o}st', 'Magnus Ohlsson', 'Bj{\\"o}rn Regnell', "Anders Wessl{\\'e}n"]</h3><h4>Ano: 2012</h4><p>?</p><br><a href="https://books.google.com.br/books?hl=en&lr=&id=QPVsM1_U8nkC&oi=fnd&pg=PR5&dq=Experimentation+in+software+engineering&ots=GPy6s8jPuq&sig=0wu53PncmrPsbH5riKIgbGL6E9I&redir_esc=y#v=onepage&q=Experimentation%20in%20software%20engineering&f=false">link</a><br><h2>Título 122: Distributed Agile, Agile Testing, and Technical Debt</h2><h3>Autores: ['R. Bavani']</h3><h4>Ano: 2012</h4><p>Agile teams create business value by responding to changing business environments and delivering working software at regular intervals. While doing so, they make design tradeoffs to satisfy business needs such as meeting a release schedule. Technical debt is the result of such decisions or tradeoffs. When this happens, agile teams must pay off the accumulated debt by improving designs during subsequent iterations in order to improve maintainability. This must happen in a systematic way so that technical debt does not swell up and damage the project. Accomplishing this is one of the major challenges in distributed agile projects. The scope of technical debt in software projects is spread across all areas including architecture, design, code, and test scripts.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/6336723">link</a><br><h2>Título 131: Configuring Global Software Teams: A Multi-company Analysis of Project Productivity, Quality, and Profits</h2><h3>Autores: ['N. Ramasubbu', 'M. Cataldo', 'R. Balan', 'J. Herbsleb']</h3><h4>Ano: 2011</h4><p>In this paper, we examined the impact of project-level configurational choices of globally distributed software teams on project productivity, quality, and profits. Our analysis used data from 362 projects of four different firms. These projects spanned a wide range of programming languages, application domain, process choices, and development sites spread over 15 countries and 5 continents. Our analysis revealed fundamental tradeoffs in choosing configurational choices that are optimized for productivity, quality, and/or profits. In particular, achieving higher levels of productivity and quality require diametrically opposed configurational choices. In addition, creating imbalances in the expertise and personnel distribution of project teams significantly helps increase profit margins. However, a profit-oriented imbalance could also significantly affect productivity and/or quality outcomes. Analyzing these complex tradeoffs, we provide actionable managerial insights that can help software firms and their clients choose configurations that achieve desired project outcomes in globally distributed software development.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/6032465">link</a><br><h2>Título 132: A survey of techniques in software repository mining</h2><h3>Autores: ['Irwin Kwan', 'Daniela Damian']</h3><h4>Ano: 2011</h4><p>Software developers’ activities are in general recorded in software repositories such as version control systems, bug trackers and mail archives. While abundant information is usually present in such repositories, successful information extraction is often challenged by the necessity to simultaneously analyze different repositories and to combine the information obtained. We propose to apply process mining techniques, originally developed for business process analysis, to address this challenge. However, in order for process mining to become applicable, different software repositories should be combined, and “related” software development events should be matched: e.g., mails sent about a file, modifications of the file and bug reports that can be traced back to it. The combination and matching of events has been implemented in FRASR (Framework for Analyzing Software Repositories), augmenting the process mining framework ProM. FRASR has been successfully applied in a series of case studies addressing such aspects of the development process as roles of different developers and the way bug reports are handled.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/5741254">link</a><br><h2>Título 133: An Enterprise Perspective on Technical Debt</h2><h3>Autores: ['Tim Klinger', 'Peri Tarr', 'Patrick Wagstrom', 'Clay Williams']</h3><h4>Ano: 2011</h4><p>Technical debt is a term that has been used to describe the increased cost of changing or maintaining a system due to expedient shortcuts taken during its development. Much of the research on technical debt has focused on decisions made by project architects and individual developers who choose to trade off short-term gain for a longer-term cost. However, in the context of enterprise software development, such a model may be too narrow. We explore the premise that technical debt within the enterprise should be viewed as a tool similar to financial leverage, allowing the organization to incur debt to pursue options that it couldn't otherwise afford. We test this premise by interviewing a set of experienced architects to understand how decisions to acquire technical debt are made within an enterprise, and to what extent the acquisition of technical debt provides leverage. We find that in many cases, the decision to acquire technical debt is not made by technical architects, but rather by non-technical stakeholders who cause the project to acquire new technical debt or discover existing technical debt that wasn't previously visible. We conclude with some preliminary observations and recommendations for organizations to better manage technical debt in the presence of some enterprise-scale circumstances.</p><br><a href="https://dl.acm.org/doi/abs/10.1145/1985362.1985371">link</a><br><h2>Título 134: Measuring and monitoring technical debt</h2><h3>Autores: ['Carolyn Seaman', 'Yuepu Guo']</h3><h4>Ano: 2011</h4><p>Technical debt is a metaphor for immature, incomplete, or inadequate artifacts in the software development lifecycle that cause higher costs and lower quality in the long run. These artifacts remaining in a system affect subsequent development and maintenance activities, and so can be seen as a type of debt that the system developers owe the system. Incurring technical debt may speed up software development in the short run, but such benefit is achieved at the cost of extra work in the future, as if paying interest on the debt. In this sense, the technical debt metaphor characterizes the relationship between the short-term benefits of delaying certain software maintenance tasks or doing them quickly and less carefully, and the long-term cost of those delays. However, managing technical debt is more complicated than managing financial debt because of the uncertainty involved. In this chapter, the authors review the main issues associated with technical debt, and propose a technical debt management framework and a research plan for validation. The objective of our research agenda is to develop and validate a comprehensive technical debt theory that formalizes the relationship between the cost and benefit sides of the concept. Further, we propose to use the theory to propose mechanisms (processes and tools) for measuring and managing technical debt in software product maintenance. The theory and management mechanisms are intended ultimately to contribute to the improved quality of software and facilitate decision making in software maintenance.</p><br><a href="https://www.sciencedirect.com/science/article/abs/pii/B9780123855121000025">link</a><br><h2>Título 135: A portfolio approach to technical debt management</h2><h3>Autores: ['Yuepu Guo', 'Carolyn Seaman']</h3><h4>Ano: 2011</h4><p>Technical debt describes the effect of immature software artifacts on software maintenance - the potential of extra effort required in future as if paying interest for the incurred debt. The uncertainty of interest payment further complicates the problem of what debt should be incurred or repaid and when. To help software managers make informed decisions, a portfolio approach is proposed in this paper. The approach leverages the portfolio management theory in the finance domain to determine the optimal collection of technical debt items that should be incurred or held. We expect this approach could provide a new perspective for technical debt management.</p><br><a href="https://dl.acm.org/doi/abs/10.1145/1985362.1985370">link</a><br><h2>Título 139: Mining software repositories--a comparative analysis</h2><h3>Autores: ['Sunday Olatunji', 'Syed Idrees', 'Yasser Al-Ghamdi', 'Jarallah Al-Ghamdi']</h3><h4>Ano: 2010</h4><p>bstract Despite of many Mining Software Repositories (MSR) tools in use, it is a relatively
new research domain, which forms the basis of classifying various tools and comparing
them. In this paper we present a comparative analysis of different tools for MSR, based on
some existing and new criteria proposed in this paper. This will assist in determining an
appropriate tool that performs the best for a given type of application and to use it directly,
instead of relying on the usual trial-and-error approach.</p><br><a href="?">link</a><br><h2>Título 141: Structural characteristic of large-scale software development network</h2><h3>Autores: ['Yi Yao', 'Song Huang', 'Li Jie', 'Xiao-ming Liu']</h3><h4>Ano: 2010</h4><p>Many real-world networks are discovered to be complex networks in the last few years. The statistical characteristic of software development network in which people are engaged and its significance are investigated. It is shown that software development network has properties of small world, and scale free. We demonstrate difference between the distribution of incoming and outgoing links of directed networks. The incoming link distribution has sharp cutoff that is lower than that of the outgoing link distribution. This asymmetry is caused by the dynamical interactions that take place in distributed software development and may be related to differences between each designer's capacity of processing information provided by others and the designer's capacity of transmitting information to others.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/5485839">link</a><br><h2>Título 140: Multicollinearity</h2><h3>Autores: ['Aylin Alin']</h3><h4>Ano: 2010</h4><p>Multicollinearity refers to the linear relationship among two or more variables, which also means lack of orthogonality among them. This relation is also called collinearity or ill conditioning by some authors like Belsley1 and Chatterjee and Hadi.2 In more technical terms, multicollinearity occurs if k vectors lie in a subspace of dimension less than k. This is the definition of exact multicollinearity or exact linear dependence. It is not necessary for multicollinearity to be exact in order to cause a problem. It is enough to have k variables nearly dependent, which occurs if the angle between one variable and its orthogonal projections onto others is small. Through this article, multicollinearity will mean near dependence. Multicollinearity is a condition of deficient data, which frequently is encountered in observational studies in which the investigator does not interfere with the study. In many studies, multicollinearity has been confused with correlation. Correlation is the linear relationship between only two variables, whereas multicollinearity can exist between two variables or between one variable and linear combination of the others. Thus, correlation is a special case of multicollinearity. High correlation implies multicollinearity, but the converse is not true. One can have multicollinearity among explanatory variables, but still not have high correlation between pairs of these variables.</p><br><a href="https://wires.onlinelibrary.wiley.com/doi/full/10.1002/wics.84">link</a><br><h2>Título 136: Theoretical maximum capacity as benchmark for empty vehicle redistribution in personal rapid transit</h2><h3>Autores: ['John Lees-Miller', 'John Hammersley', 'R Wilson']</h3><h4>Ano: 2010</h4><p>A personal rapid transit system uses compact, computer-guided vehicles running on dedicated guideways to carry individuals or small groups directly between pairs of stations. Vehicles move on demand when a passenger requests service at his or her origin station. Because the number of trips requested from a station need not equal the number of trips ending there, some vehicles must run empty to balance the flows. The empty vehicle redistribution (EVR) problem is to decide which empty vehicles to move and when and where to move them; an EVR algorithm makes these decisions in real time, as passengers arrive and request service. A method was developed for finding the theoretical maximum demand (with a given spatial distribution) that a given system could serve with any EVR algorithm, which provides a benchmark against which particular EVR algorithms can be compared. The maximum passenger demand that a particular EVR algorithm can serve can be determined by simulation and then compared with the benchmark. The method is applied to two simple EVR heuristics on two example systems. The results suggest that this is a useful method for determining the strengths and weaknesses of a variety of EVR heuristics across a range of networks, passenger demands, and fleet sizes.</p><br><a href="https://journals.sagepub.com/doi/abs/10.3141/2146-10">link</a><br><h2>Título 138: Replicating msr: A study of the potential replicability of papers published in the mining software repositories proceedings</h2><h3>Autores: ['Gregorio Robles']</h3><h4>Ano: 2010</h4><p>This paper is the result of reviewing all papers published in the proceedings of the former International Workshop on Mining Software Repositories (MSR) (2004-2006) and now Working Conference on MSR (2007-2009). We have analyzed the papers that contained any experimental analysis of software projects for their potentiality of being replicated. In this regard, three main issues have been addressed: i) the public availability of the data used as case study, ii) the public availability of the processed dataset used by researchers and iii) the public availability of the tools and scripts. A total number of 171 papers have been analyzed from the six workshops/working conferences up to date. Results show that MSR authors use in general publicly available data sources, mainly from free software repositories, but that the amount of publicly available processed datasets is very low. Regarding tools and scripts, for a majority of papers we have not been able to find any tool, even for papers where the authors explicitly state that they have built one. Lessons learned from the experience of reviewing the whole MSR literature and some potential solutions to lower the barriers of replicability are finally presented and discussed.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/5463348">link</a><br><h2>Título 137: Managing technical debt in software-reliant systems</h2><h3>Autores: ['Nanette Brown', 'Yuanfang Cai', 'Yuepu Guo', 'Rick Kazman', 'Miryung Kim', 'Philippe Kruchten', 'Erin Lim', 'Alan MacCormack', 'Robert Nord', 'Ipek Ozkaya', 'others']</h3><h4>Ano: 2010</h4><p>Delivering increasingly complex software-reliant systems demands better ways to manage the long-term effects of short-term expedients. The technical debt metaphor is gaining significant traction in the agile development community as a way to understand and communicate such issues. The idea is that developers sometimes accept compromises in a system in one dimension (e.g., modularity) to meet an urgent demand in some other dimension (e.g., a deadline), and that such compromises incur a "debt": on which "interest" has to be paid and which the "principal" should be repaid at some point for the long-term health of the project. We argue that the software engineering research community has an opportunity to study and improve this concept. We can offer software engineers a foundation for managing such trade-offs based on models of their economic impacts. Therefore, we propose managing technical debt as a part of the future research agenda for the software engineering field.</p><br><a href="https://dl.acm.org/doi/abs/10.1145/1882362.1882373">link</a><br><h2>Título 142: Global Software Development: Where Are the Benefits?</h2><h3>Autores: ["E. Conch\\'{u}ir", 'P. {\\AA}gerfalk', 'H. Holmstrom', 'B. Fitzgerald']</h3><h4>Ano: 2009</h4><p>Global Software Development (GSD) is increasingly becoming the normal practice in the software industry, readily evidenced by U.S. estimates that the value of the offshore software development market has increased 25-fold over the past 10 years, to the extent that one-quarter of U.S. spending on application development, integration and management services is expected to go off-shore according to recent predictions. There are many potential benefits that can arise from GSD. The most frequently cited one is that of reduced development costs due to the salary savings possible. Also, GSD can lead to reduced development duration due to greater time zone effectiveness as companies practice the so-called 'follow-the-sun' software development model. GSD also affords new opportunities for cross-site modularization of development work, potential access to a larger and better-skilled developer pool, and the possibility of greater innovation, learning and transfer of best practices. Finally, GSD can facilitate closer proximity to markets and customers.
However, GSD also introduces a number of challenges in relation to communication, coordination and control of the development process. These arise due to the distances involved in three dimensions -- geographical, temporal, and socio-cultural (See Figure 1). As a consequence, much research and practice has focused on trying to find ways to overcome the GSD challenges identified in Figure 1. In the literature to date, the potential benefits of GSD are usually just mentioned very briefly, if they are mentioned at all, and the realization of these benefits seems to be more or less taken for granted. The primary focus instead is on how the problems inherent in GSD might be addressed. Here, we reverse this trend and focus instead on the benefits and the extent to which they are actually being realized in practice in three global companies practicing GSD.</p><br><a href="https://dl.acm.org/doi/abs/10.1145/1536616.1536648">link</a><br><h2>Título 143: Software architecture: foundations, theory, and practice</h2><h3>Autores: ['Richard Taylor', 'Nenad Medvidovic', 'Eric Dashofy']</h3><h4>Ano: 2009</h4><p>Software architecture has become a centerpiece subject for software engineers, both researchers and practitioners alike. At the heart of every software system is its software architecture, i.e., "the set of principal design decisions about the system". Architecture permeates all major facets of a software system, for principal design decisions may potentially be made at any time during a system's lifetime, and potentially by any stakeholder. Such decisions encompass structural concerns, such as the system's high-level building blocks -components, connectors, and configurations; the system's deployment; the system's non-functional properties; and the system's evolution patterns, including runtime adaptation. Software architectures found particularly useful for families of systems - product lines - are often codified into architectural patterns, architectural styles, and reusable, parameterized reference architectures. This tutorial affords the participant an extensive treatment of the field of software architecture, its foundation, principles, and elements, including those mentioned above. Additionally, the tutorial introduces the participants to the state-of-the-art as well as the state-of-the-practice in software architecture, and looks at emerging and likely future trends in this field. The discussion is illustrated with numerous real-world examples. One example given prominent treatment is the architecture of the World Wide Web and its underlying architectural style, REpresentational State Transfer (REST).</p><br><a href="https://ieeexplore.ieee.org/abstract/document/6062253">link</a><br><h2>Título 144: Cyclomatic complexity and lines of code: empirical evidence of a stable linear relationship</h2><h3>Autores: ['Jay Graylin', 'Joanne Hale', 'Randy Smith', 'Hale David', 'Nicholas Kraft', 'WARD Charles', 'others']</h3><h4>Ano: 2009</h4><p>?</p><br><a href="https://www.scirp.org/html/779.html">link</a><br><h2>Título 145: Systematic mapping studies in software engineering</h2><h3>Autores: ['Kai Petersen', 'Robert Feldt', 'Shahid Mujtaba', 'Michael Mattsson']</h3><h4>Ano: 2008</h4><p>A software engineering systematic map is a defined method to build a classification scheme and structure a software engineering field of interest. The analysis of results focuses on frequencies of publications for categories within the scheme. Thereby, the coverage of the research field can be determined. Different facets of the scheme can also be combined to answer more specific research questions. OBJECTIVE: We describe how to conduct a systematic mapping study in software engineering and provide guidelines. We also compare systematic maps and systematic reviews to clarify how to chose between them. This comparison leads to a set of guidelines for systematic maps. METHOD: We have defined a systematic mapping process and applied it to complete a systematic mapping study. Furthermore, we compare systematic maps with systematic reviews by systematically analyzing existing systematic reviews. RESULTS: We describe a process for software engineering systematic mapping studies and compare it to systematic reviews. Based on this, guidelines for conducting systematic maps are defined. CONCLUSIONS: Systematic maps and reviews are different in terms of goals, breadth, validity issues and implications. Thus, they should be used complementarily and require different methods (e.g., for analysis).</p><br><a href="https://www.scienceopen.com/hosted-document?doi=10.14236/ewic/EASE2008.8">link</a><br><h2>Título 146: The road ahead for mining software repositories</h2><h3>Autores: ['Ahmed Hassan']</h3><h4>Ano: 2008</h4><p>Source control repositories, bug repositories, archived communications, deployment logs, and code repositories are examples of software repositories that are commonly available for most software projects. The mining software repositories (MSR) field analyzes and cross-links the rich data available in these repositories to uncover interesting and actionable information about software systems. By transforming these repositories from static record-keeping ones into active repositories, we can guide decision processes in modern software projects. For example, data in source control repositories, traditionally used to archive code, could be linked with data in bug repositories to help practitioners propagate complex changes and to warn them about risky code based on prior changes and bugs. In this paper, we present a brief history of the MSR field and discuss several recent achievements and results of using MSR techniques to support software research and practice. We then discuss the various opportunities and challenges that lie in the road ahead for this important and emerging field.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/4659248">link</a><br><h2>Título 147: The qualitative content analysis process</h2><h3>Autores: ['Satu Elo', 'Helvi Kyngas']</h3><h4>Ano: 2008</h4><p>Aim. This paper is a description of inductive and deductive content analysis.
Background. Content analysis is a method that may be used with either qualitative or quantitative data and in an inductive or deductive way. Qualitative content analysis is commonly used in nursing studies but little has been published on the analysis process and many research books generally only provide a short description of this method.
Discussion. When using content analysis, the aim was to build a model to describe the phenomenon in a conceptual form. Both inductive and deductive analysis processes are represented as three main phases: preparation, organizing and reporting. The preparation phase is similar in both approaches. The concepts are derived from the data in inductive content analysis. Deductive content analysis is used when the structure of analysis is operationalized on the basis of previous knowledge.
Conclusion. Inductive content analysis is used in cases where there are no previous studies dealing with the phenomenon or when it is fragmented. A deductive approach is useful if the general aim was to test a previous theory in a different situation or to compare categories at different time periods.</p><br><a href="https://onlinelibrary.wiley.com/doi/full/10.1111/j.1365-2648.2007.04569.x">link</a><br><h2>Título 148: Codecity: 3d visualization of large-scale software</h2><h3>Autores: ['Richard Wettel', 'Michele Lanza']</h3><h4>Ano: 2008</h4><p>CodeCity is a language-independent interactive 3D visualization tool for the analysis of large software systems. Based on a city metaphor, it depicts classes as buildings and packages as districts of a "software city". By offering consistent locality and solid orientation points we keep the viewer oriented during the exploration of a city. We applied our tool on several large-scale industrial systems.</p><br><a href="https://dl.acm.org/doi/abs/10.1145/1370175.1370188">link</a><br><h2>Título 152: Do Gradations of Time Zone Separation Make a Difference in Performance? A First Laboratory Study</h2><h3>Autores: ['J. Espinosa', 'N. Nan', 'E. Carmel']</h3><h4>Ano: 2007</h4><p>We often hear that global software engineering teams are affected by time differences. While there is considerable research on the difficulties of distance, culture and other dimensions, there has been little research that isolated the impact of just time differences. The research question that guides us is whether there are gradual differences across time zones that impact team performance. In this study we conducted a laboratory experiment with 42 dyadic teams. The teams were randomly assigned into 4 time zone overlap conditions: full overlap, 2/3 overlap, 1/3 overlap and no overlap. Using a fictional map task, we found that participants' perceptions of process are unrelated to actual objective performance measures of speed and accuracy. Consistent with our expectations, we found that a small time separation has no effect on accuracy, but that more time separation has a significant effect on accuracy. Also consistent with our expectations, we found that a small amount of time separation has a significant effect on production speed. However, contrary to our expectations, we found that further increases in partial overlap have less significant effects on speed, and when there is no overlap speed actually increases, albeit not significantly - a "U-shaped" effect.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/4299835">link</a><br><h2>Título 151: Understanding Documentation Value in Software Maintenance</h2><h3>Autores: ['Sumita Das', 'Wayne Lutters', 'Carolyn Seaman']</h3><h4>Ano: 2007</h4><p>This study examines effective documentation use in software maintenance. Interviews with software maintainers, with diverse levels of experience, revealed three themes: reliance on source code, characteristics of useful documents, and the interplay between people in the maintenance environment and documentation. All of these findings improve our understanding of the role of documentation in maintenance. This awareness has practical import - project managers can fund the most useful forms of documentation and maintainers can improve their ability to locate and reuse this information.</p><br><a href="https://dl.acm.org/doi/abs/10.1145/1234772.1234790">link</a><br><h2>Título 149: Guidelines for performing systematic literature reviews in software engineering</h2><h3>Autores: ['Barbara Kitchenham', 'Stuart Charters']</h3><h4>Ano: 2007</h4><p>?</p><br><a href="https://www.researchgate.net/profile/Barbara-Kitchenham/publication/302924724_Guidelines_for_performing_Systematic_Literature_Reviews_in_Software_Engineering/links/61712932766c4a211c03a6f7/Guidelines-for-performing-Systematic-Literature-Reviews-in-Software-Engineering.pdf">link</a><br><h2>Título 150: Identifying changed source code lines from version repositories</h2><h3>Autores: ['Gerardo Canfora', 'Luigi Cerulo', 'Massimiliano Di Penta']</h3><h4>Ano: 2007</h4><p>Observing the evolution of software systems at different levels of granularity has been a key issue for a number of studies, aiming at predicting defects or at studying certain phenomena, such as the presence of clones or of crosscutting concerns. Versioning systems such as CVS and SVN, however, only provide information about lines added or deleted by a contributor: any change is shown as a sequence of additions and deletions. This provides an erroneous estimate of the amount of code changed. This paper shows how the evolution of changes at source code line level can be inferred from CVS repositories, by combining information retrieval techniques and the Levenshtein edit distance. The application of the proposed approach to the ArgoUML case study indicates a high precision and recall.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/4228651">link</a><br><h2>Título 153: Requirements engineering paper classification and evaluation criteria: a proposal and a discussion</h2><h3>Autores: ['Roel Wieringa', 'Neil Maiden', 'Nancy Mead', 'Colette Rolland']</h3><h4>Ano: 2006</h4><p>In recent years, members of the steering committee of the IEEE Requirements Engineering (RE) Conference have discussed paper classification and evaluation criteria for RE papers. The immediate trigger for this discussion was our concern about differences in opinion that sometimes arise in program committees about the criteria to be used in evaluating papers. If program committee members do not all use the same criteria, or if they use criteria different from those used by authors, then papers might be rejected or accepted for the wrong reasons. Surely not all papers should be evaluated according to the same criteria. Some papers describe new techniques but do not report on empirical research; others describe new conceptual frameworks for investigating certain RE problems; others report on industrial experience with existing RE techniques. Other kinds of papers can also be easily recognized. All of these types of papers should be evaluated according to different criteria. But we are far from a consensus about what classes of paper we should distinguish, and what the criteria are for each of these classes.</p><br><a href="https://link.springer.com/article/10.1007/s00766-005-0021-6">link</a><br><h2>Título 154: Static evaluation of software architectures</h2><h3>Autores: ['Jens Knodel', 'Mikael Lindvall', 'Dirk Muthig', 'Matthias Naab']</h3><h4>Ano: 2006</h4><p>The software architecture is one of the most crucial artifacts within the lifecycle of a software system. Decisions made at the architectural level directly enable, facilitate, hamper, or interfere with the achievement of business goals, functional and quality requirements. Architecture evaluations play an important role in the development and evolution of software systems since they determine how adequate the architecture is for its intended usage. This paper summarizes our practical experience with using architecture evaluations and gives an overview on when and how static architecture evaluations contribute to architecture development. We identify ten distinct purposes and needs for static architecture evaluations and illustrate them using a set of industrial and academic case studies. In particular, we show how subsequent steps in architecture development are influenced by the results from architecture evaluations</p><br><a href="https://ieeexplore.ieee.org/abstract/document/1602379">link</a><br><h2>Título 155: Uncovering the Reality Within Virtual Software Teams</h2><h3>Autores: ['Valentine Casey', 'Ita Richardson']</h3><h4>Ano: 2006</h4><p>To support software development globalisation, organisations are increasingly implementing virtual team strategies. However, these teams have to work within the confines of the factors which distance introduces, thus not always allowing effective coordination, visibility, communication and cooperation to take place. The successful implementation and management of such teams must be done differently to those at single-site locations. To establish what factors significantly affect the implementation of virtual teams, the authors carried out qualitative research in two organisations in Ireland. Results from this research demonstrate that many factors are reality for those involved in global software development. In this paper we present five of these factors and discuss the impact these had on the virtual teams. These five are: use of communication tools, project management, process engineering, technical ability and knowledge transfer and motivational issues. If these are not explicitly addressed by management it can lead to serious problems.</p><br><a href="https://dl.acm.org/doi/abs/10.1145/1138506.1138523">link</a><br><h2>Título 156: Suitability of requirements prioritization methods for market-driven software product development</h2><h3>Autores: ['Laura Lehtola', 'Marjo Kauppinen']</h3><h4>Ano: 2006</h4><p>In a company producing off-the-shelf software for mass markets, the future development steps of the products cannot be negotiated with one or few customers. The decisions concerning the priorities of the requirements must be made within the company, the developer bearing all the financial risks included. This means that finding the right priorities for the requirements is important. However, requirements prioritization is recognized as a difficult activity in software product development. The literature offers methods for requirements prioritization, but many authors report that practices in companies are mostly informal. In this study, we evaluated two requirements prioritization methods in industrial product development projects. In the first case, the users of the system evaluated the pair-wise comparison technique for prioritizing user needs. In the second case, practitioners evaluated Wiegers' method for change requests. In addition, we interviewed 11 practitioners from 6 companies about their current requirements prioritization practices and the models that they use as a basis of their prioritization decisions. Our findings indicate that prioritization methods may have limited ability to support decision-making in a complex area like requirements prioritization in market-driven product development. In addition, there are practical difficulties in the usage of methods, and therefore, prioritization results should be taken more as being indicative than as an ultimate truth.</p><br><a href="https://onlinelibrary.wiley.com/doi/abs/10.1002/spip.249">link</a><br><h2>Título 157: Systematic reviews and meta-analyses: an illustrated, step-by-step guide.</h2><h3>Autores: ['Madhukar Pai', 'Michael McCulloch', 'Jennifer Gorman', 'Nitika Pai', 'Wayne Enanoria', 'Gail Kennedy', 'Prathap Tharyan', 'Jr Colford']</h3><h4>Ano: 2004</h4><p>Systematic reviews and meta-analyses synthesize data from existing primary research, and well-conducted reviews offer clinicians a practical solution to the problem of staying current in their fields of interest. A whole generation of secondary journals, pre-appraised evidence libraries and periodically updated electronic texts are now available to clinicians. However, not all systematic reviews are of high quality, and it is important to be able to critically assess their validity and applicability. This article is an illustrated guide for conducting systematic reviews. A clear understanding of the process will provide clinicians with the tools to judiciously appraise reviews and interpret them. We hope that it will enable clinicians to conduct systematic reviews, generate high-quality evidence, and contribute to the evidence-based medicine movement.</p><br><a href="https://europepmc.org/article/med/15141602">link</a><br><h2>Título 158: Predicting change propagation in software systems</h2><h3>Autores: ['Ahmed Hassan', 'Richard Holt']</h3><h4>Ano: 2004</h4><p>Software systems contain entities, such as functions and variables, which are related to each other. As a software system evolves to accommodate new features and repair bugs, changes occur to these entities. Developers must ensure that related entities are updated to be consistent with these changes. This paper addresses the question: How does a change in one source code entity propagate to other entities? We propose several heuristics to predict change propagation. We present a framework to measure the performance of our proposed heuristics. We validate our results empirically using data obtained by analyzing the development history for five large open source software systems.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/1357812">link</a><br><h2>Título 160: Software architecture in practice</h2><h3>Autores: ['Len Bass', 'Paul Clements', 'Rick Kazman']</h3><h4>Ano: 2003</h4><p>?</p><br><a href="https://books.google.com.br/books?hl=en&lr=&id=mdiIu8Kk1WMC&oi=fnd&pg=PA1&dq=Software+architecture+in+practice&ots=UfO2T3f9LN&sig=Y4AkjvP2B8GvLyREPTyKVekyhoE&redir_esc=y#v=onepage&q=Software%20architecture%20in%20practice&f=false">link</a><br><h2>Título 159: An empirical study of speed and communication in globally distributed software development</h2><h3>Autores: ['J. Herbsleb', 'A. Mockus']</h3><h4>Ano: 2003</h4><p>Global software development is rapidly becoming the norm for technology companies. Previous qualitative research suggests that distributed development may increase development cycle time for individual work items (modification requests). We use both data from the source code change management system and survey data to model the extent of delay in a distributed software development organization and explore several possible mechanisms for this delay. One key finding is that distributed work items appear to take about two and one-half times as long to complete as similar items where all the work is colocated. The data strongly suggest a mechanism for the delay, i.e., that distributed work items involve more people than comparable same-site work items, and the number of people involved is strongly related to the calendar time to complete a work item. We replicate the analysis of change data in a different organization with a different product and different sites and confirm our main findings. We also report survey results showing differences between same-site and distributed social networks, testing several hypotheses about characteristics of distributed social networks that may be related to delay. We discuss implications of our findings for practices and collaboration technology that have the potential for dramatically speeding distributed software development.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/1205177">link</a><br><h2>Título 161: Tactical Approaches for Alleviating Distance in Global Software Development</h2><h3>Autores: ['E. Carmel', 'R. Agarwal']</h3><h4>Ano: 2001</h4><p>To overcome the problem of distance in global software development, various managers are experimenting and quickly adjusting their tactical approaches. We discuss some emerging approaches and explain their motivations from conceptual and practical perspectives. The most intuitive approach for alleviating distance is to apply communication technologies, but this is not our focus. Rather, we examine tactics that go beyond communication technologies, tactics aimed at reducing intensive collaboration, national and organizational cultural differences, and temporal distance.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/914734">link</a><br><h2>Título 163: Global software development</h2><h3>Autores: ['J. Herbsleb', 'D. Moitra']</h3><h4>Ano: 2001</h4><p>The last several decades have witnessed a steady, irreversible trend toward the globalization of business, and of software-intensive high-technology businesses in particular. Economic forces are relentlessly turning national markets into global markets and spawning new forms of competition and cooperation that reach across national boundaries. This change is having a profound impact not only on marketing and distribution but also on the way produces are conceived, designed, constructed, tested, and delivered to customers. The author considers how software development is increasingly a multisite, multicultural, globally distributed undertaking.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/914732">link</a><br><h2>Título 162: Ordered treemap layouts</h2><h3>Autores: ['Ben Shneiderman', 'Martin Wattenberg']</h3><h4>Ano: 2001</h4><p>Treemaps, a space-filling method of visualizing large
hierarchical data sets, are receiving increasing attention.
Several algorithms have been proposed to create more
useful displays by controlling the aspect ratios of the
rectangles that make up a treemap. While these
algorithms do improve visibility of small items in a single
layout, they introduce instability over time in the display
of dynamically changing data, and fail to preserve an
ordering of the underlying data. This paper introduces the
ordered treemap, which addresses these two
shortcomings. The ordered treemap algorithm ensures
that items near each other in the given order will be near
each other in the treemap layout. Using experimental
evidence from Monte Carlo trials, we show that compared
to other layout algorithms ordered treemaps are more
stable while maintaining relatively favorable aspect ratios
of the constituent rectangles. A second test set uses stock
market data. </p><br><a href="http://www.ifs.tuwien.ac.at/~mlanzenberger/teaching/ps/ws08/stuff/00963283.pdf">link</a><br><h2>Título 164: Squarified treemaps</h2><h3>Autores: ['Mark Bruls', 'Kees Huizing', 'Jarke Wijk']</h3><h4>Ano: 2000</h4><p>An extension to the treemap method for the visualization of hierarchical information, such as directory structures and Organization structures, is presented. The Standard treemap method often gives thin, elongated rectangles. As a result, rectangles are difficult to compare and to select. A new method is presented to generate lay-outs in which the rectangles approximate squares. To strenghten the visualization of the structure, shaded frames are used around groups of related nodes.</p><br><a href="https://link.springer.com/chapter/10.1007/978-3-7091-6783-0_4">link</a><br><h2>Título 165: Effects of Process Maturity on Quality, Cycle Time, and Effort in Software Product Development</h2><h3>Autores: ['Donald Harter', 'Mayuram Krishnan', 'Sandra Slaughter']</h3><h4>Ano: 2000</h4><p>The information technology (IT) industry is characterized by rapid innovation and intense competition. To survive, IT firms must develop high quality software products on time and at low cost. A key issue is whether high levels of quality can be achieved without adversely impacting cycle time and effort. Conventional beliefs hold that processes to improve software quality can be implemented only at the expense of longer cycle times and greater development effort. However, an alternate view is that quality improvement, faster cycle time, and effort reduction can be simultaneously attained by reducing defects and rework. In this study, we empirically investigate the relationship between process maturity, quality, cycle time, and effort for the development of 30 software products by a major IT firm. We find that higher levels of process maturity as assessed by the Software Engineering Institute's Capability Maturity Model™ are associated with higher product quality, but also with increases in development effort. However, our findings indicate that the reductions in cycle time and effort due to improved quality outweigh the increases from achieving higher levels of process maturity. Thus, the net effect of process maturity is reduced cycle time and development effort.</p><br><a href="https://pubsonline.informs.org/doi/abs/10.1287/mnsc.46.4.451.12056">link</a><br><h2>Título 166: Tree-maps: A space-filling approach to the visualization of hierarchical</h2><h3>Autores: ['Brian Johnson', 'Ben Shneiderman']</h3><h4>Ano: 1999</h4><p>This paper describes a novel method for the visualization of hierarchically structured information. The Tree-Map visualization technique makes 100% use of theavailable display space, mapping the full hierarchy onto a rectangular region in a space-filling manner. This efficient use of space allows very large hierarchies to be displayed in their entirety and facilitates the presentation of semantic information.</p><br><a href="https://drum.lib.umd.edu/handle/1903/370">link</a><br><h2>Título 167: Content analysis: concepts, methods and applications.</h2><h3>Autores: ['Stephen Cavanagh']</h3><h4>Ano: 1997</h4><p>Content analysis is much more than a naive technique that results in a simplistic description of data. It allows the researcher to test theoretical issues to enhance understanding of the data. Using applications from the nursing and health literature, this paper will explain key concepts and methodological issues, including strategies for data analysis.</p><br><a href="https://europepmc.org/article/med/27285770">link</a><br><h2>Título 168: Management of distributed concurrent development for large scale software systems</h2><h3>Autores: ['Mikio Aoyama']</h3><h4>Ano: 1995</h4><p>The article discusses a new software process model, distributed concurrent development, and its experience in developing a family of large-scale communication software systems. We have experienced an evolutionary change of our software development process. The change is spread into two dimensions, that is, from sequential to concurrent, and from centralized to distributed. With the concurrent development process model, multiple functions to a single software system are concurrently developed from the beginning of the development process, i.e. requirement specification, to system testing. In the distributed development process model, the development organization is decentralized into multiple development sites which are geographically distributed. The two dimensional changes require a fundamental re-think of our software process and brought about a significant impact on every aspect of software development activities ranging from individual developers to the entire project. We discuss the model, the issues in implementing the model, and our total system of managing the process, project and products.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/496964">link</a><br><h2>Título 169: A metrics suite for object oriented design</h2><h3>Autores: ['Shyam Chidamber', 'Chris Kemerer']</h3><h4>Ano: 1994</h4><p>Given the central role that software development plays in the delivery and application of information technology, managers are increasingly focusing on process improvement in the software development area. This demand has spurred the provision of a number of new and/or improved approaches to software development, with perhaps the most prominent being object-orientation (OO). In addition, the focus on process improvement has increased the demand for software measures, or metrics with which to manage the process. The need for such metrics is particularly acute when an organization is adopting a new technology for which established practices have yet to be developed. This research addresses these needs through the development and implementation of a new suite of metrics for OO design. Metrics developed in previous research, while contributing to the field's understanding of software development processes, have generally been subject to serious criticisms, including the lack of a theoretical base. Following Wand and Weber (1989), the theoretical base chosen for the metrics was the ontology of Bunge (1977). Six design metrics are developed, and then analytically evaluated against Weyuker's (1988) proposed set of measurement principles. An automated data collection tool was then developed and implemented to collect an empirical sample of these metrics at two field sites in order to demonstrate their feasibility and suggest ways in which managers may use these metrics for process improvement.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/295895">link</a><br><h2>Título 171: The WyCash Portfolio Management System</h2><h3>Autores: ['Ward Cunningham']</h3><h4>Ano: 1992</h4><p>?</p><br><a href="https://dl.acm.org/doi/pdf/10.1145/157710.157715">link</a><br><h2>Título 170: Foundations for the study of software architecture</h2><h3>Autores: ['Dewayne Perry', 'Alexander Wolf']</h3><h4>Ano: 1992</h4><p>The purpose of this paper is to build the foundation for software architecture. We first develop an intuition for software architecture by appealing to several well-established architectural disciplines. On the basis of this intuition, we present a model of software architecture that consists of three components: elements, form, and rationale. Elements are either processing, data, or connecting elements. Form is defined in terms of the properties of, and the relationships among, the elements --- that is, the constraints on the elements. The rationale provides the underlying basis for the architecture in terms of the system constraints, which most often derive from the system requirements. We discuss the components of the model in the context of both architectures and architectural styles and present an extended example to illustrate some important architecture and style considerations. We conclude by presenting some of the benefits of our approach to software architecture, summarizing our contributions, and relating our approach to other current work.</p><br><a href="https://dl.acm.org/doi/abs/10.1145/141874.141884">link</a><br><h2>Título 172: Influential observations, high leverage points, and outliers in linear regression</h2><h3>Autores: ['Samprit Chatterjee', 'Ali Hadi']</h3><h4>Ano: 1986</h4><p>?</p><br><a href="https://www.jstor.org/stable/2245477?seq=1">link</a><br><h2>Título 173: Robust tests for heteroscedasticity based on regression quantiles</h2><h3>Autores: ['Roger Koenker', 'Gilbert Bassett Jr']</h3><h4>Ano: 1982</h4><p>?</p><br><a href="https://www.jstor.org/stable/1912528?seq=1">link</a><br><h2>Título 174: A complexity measure</h2><h3>Autores: ['Thomas McCabe']</h3><h4>Ano: 1976</h4><p>This paper describes a graph-theoretic complexity measure and illustrates how it can be used to manage and control program complexity. The paper first explains how the graph-theory concepts apply and gives an intuitive explanation of the graph concepts in programming terms. The control graphs of several actual Fortran programs are then presented to illustrate the correlation between intuitive complexity and the graph-theoretic complexity. Several properties of the graph-theoretic complexity are then proved which show, for example, that complexity is independent of physical size (adding or subtracting functional statements leaves complexity unchanged) and complexity depends only on the decision structure of a program.</p><br><a href="https://ieeexplore.ieee.org/abstract/document/1702388">link</a><br><h2>Título 175: The mythical man-month</h2><h3>Autores: ['Frederick Brooks']</h3><h4>Ano: 1974</h4><p>?</p><br><a href="https://dl.acm.org/doi/abs/10.5555/207583">link</a><br><h2>Título 176: The theory of a general quantum system interacting with a linear dissipative system</h2><h3>Autores: ['R.P Feynman', 'F.L {Vernon Jr.}']</h3><h4>Ano: 1963</h4><p>A formalism has been developed, using Feynman's space-time formulation of nonrelativistic quantum mechanics whereby the behavior of a system of interest, which is coupled to other external quantum systems, may be calculated in terms of its own variables only. It is shown that the effect of the external systems in such a formalism can always be included in a general class of functionals (influence functionals) of the coordinates of the system only. The properties of influence functionals for general systems are examined. Then, specific forms of influence functionals representing the effect of definite and random classical forces, linear dissipative systems at finite temperatures, and combinations of these are analyzed in detail. The linear system analysis is first done for perfectly linear systems composed of combinations of harmonic oscillators, loss being introduced by continuous distributions of oscillators. Then approximately linear systems and restrictions necessary for the linear behavior are considered. Influence functionals for all linear systems are shown to have the same form in terms of their classical response functions. In addition, a fluctuation-dissipation theorem is derived relating temperature and dissipation of the linear system to a fluctuating classical potential acting on the system of interest which reduces to the Nyquist–Johnson relation for noise in the case of electric circuits. Sample calculations of transition probabilities for the spontaneous emission of an atom in free space and in a cavity are made. Finally, a theorem is proved showing that within the requirements of linearity all sources of noise or quantum fluctuation introduced by maser-type amplification devices are accounted for by a classical calculation of the characteristics of the maser.</p><br><a href="https://www.sciencedirect.com/science/article/pii/S0003491600960172">link</a><br><h2>Título 177: Implications of surface temperatures in the diagnosis of breast cancer</h2><h3>Autores: ['Ray Lawson']</h3><h4>Ano: 1956</h4><p>?</p><br><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1824571/">link</a><br><h2>Título 178: The lorentz transformation and absolute time</h2><h3>Autores: ['P.A.M. Dirac']</h3><h4>Ano: 1953</h4><p>?</p><br><a href="https://www.sciencedirect.com/science/article/pii/S0031891453800996">link</a><br></body></html>